What are semantic HTML tags and why are they important?

Meaningful structure	Easier to read and understand
Accessibility	        Helps screen readers and assistive tech
SEO	                    Helps search engines interpret content more accurately
Maintainability	        Easy to maintain, update, and scale


Difference between <section>, <article>, and <div>?

<div>	    Plain cardboard box (no label)      no use in SEO 
<section>	Labeled box with grouped items      slightly use in SEO 
<article>	A single complete book or magazine  very useful in SEO 


How does the CSS specificity hierarchy work?

Inline styles > IDs > Classes > Elements


What is the difference between em, rem, %, and px?

px ‚Üí Absolute unit; always the same fixed size regardless of anything else.

% ‚Üí Relative to the parent's size (width/height or font-size depending on the property).

em ‚Üí Relative to the element‚Äôs own font-size, which may be inherited or explicitly set.

rem ‚Üí Relative to the root (<html>) font-size, providing consistent scaling across the page.\\\


Flexbox vs Grid ‚Äì when to use each?

you should use both grid and flexbox in a page 
    grid is like a structure of a page 
    flex is like a structure of a row

    flex-direction	Main	Container	Set layout direction (row or column)
    justify-content	Main	Container	Align/space items on main axis
    align-items	    Cross	Container	Align all items on cross axis
    flex-wrap	    N/A	    Container	Allow items to wrap
    flex-grow	    Main	Item	    Control growth when extra space exists
    flex-shrink	    Main	Item	    Control shrink when space is tight
    flex-basis	    Main	Item	    Set initial/preferred size
    align-self	    Cross	Item	    Align one item differently


What is the difference between absolute, relative, fixed, and sticky positioning?

Feature	                static	relative	absolute	fixed	sticky
Takes up space	        ‚úÖ	    ‚úÖ	    ‚ùå	        ‚ùå	    ‚úÖ
Removed from flow	    ‚ùå	    ‚ùå	    ‚úÖ	        ‚úÖ	    ‚ùå
Scrolls with page	    ‚úÖ	    ‚úÖ	    ‚ùå	        ‚ùå	    ‚úÖ/‚ùå
Parent reference	    N/A	    Self	    Nearest  	Viewport	Scroll container
                                            positioned
                                            ancestor


Explain reflow vs repaint.

Reflow	Browser recalculates layout (sizes, positions) ‚Äî expensive
Repaint	Browser redraws visuals (color, shadows) ‚Äî lighter


What is Critical CSS and how can it improve performance?

Critical CSS is the minimum CSS needed to render above-the-fold content quickly 
‚Äî it boosts page speed, SEO, and user experience by reducing render-blocking.


What Are Web Vitals?

Web Vitals are a set of metrics defined by Google to measure the real-world \
performance of a webpage ‚Äî especially user experience.


3 core web vitals 
    LCP - largest contentful page 
    FID - first input delay 
    CLS - cumulative layout shift


How do media queries work?

Media queries let you apply CSS conditionally based on device or screen properties 
(like width, orientation, resolution) ‚Äî essential for making responsive websites.


What is z-index and how does stacking context work?

The z-index in CSS controls the stacking order of elements along the z-axis (depth) 
‚Äî i.e., which element appears in front of or behind another.

A stacking context is a local environment that controls how child elements are 
stacked inside it, independently of the rest of the page.

üîê Children are bound by the rules of their parent stacking context.




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~js~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Hoisting is JavaScript's default behavior of moving declarations to the top of their 
scope during the compile phase (before the code runs).


var	                                ‚úÖ Yes	undefined	Function-scoped, can be re-declared
let & const	                        ‚úÖ Yes	‚ùå          Not initialized	Exists in Temporal Dead Zone
function	                        ‚úÖ   Yes	‚úÖ          Fully hoisted	Can call before definition
arrow function (const x = () => {})	‚ùå No	‚ùå          Not hoisted	Treated as variable


var	    Function-scoped, hoisted, can be re-declared ‚Üí legacy use
let	    Block-scoped, hoisted (TDZ), reassignable ‚Üí modern variable
const	Block-scoped, hoisted (TDZ), no reassignment ‚Üí use for constants


== compares values after converting types (loose equality), while === compares both value and type without 
conversion (strict equality) ‚Äî always prefer ===.

A closure is a function that remembers its outer lexical scope even after the outer function has finished executing.

Yes, closures in JavaScript often mimic or support OOP principles, even though closures themselves are 
not OOP-specific constructs.

JavaScript can only do one thing at a time ‚Äî it has one main thread where all code runs.


Call Stack	                Runs your actual code ‚Äî handles function calls (LIFO: last-in-first-out)
Web APIs	                Browser-provided features (setTimeout, DOM, fetch, etc.)
Callback Queue (Task Queue)	Stores callback functions waiting to run
Event Loop	                Keeps checking if the stack is empty, then pushes queued tasks


The call stack executes your code, the event loop keeps watching it, and async callbacks 
(via Web APIs) are queued and pushed onto the stack only when it‚Äôs empty ‚Äî making JavaScript 
non-blocking and fast.


A Promise is a JavaScript object that represents the eventual result (or failure) of an asynchronous operation.

async/await is for more complex logic while .then and .catch are more for simpler logic


Debouncing	Group a burst of events into one execution after a delay
Throttling	Ensure a function is called at most once every X ms, no matter how many times the event fires

Debouncing delays function execution until after a pause in events,
while throttling ensures the function runs at most once in a fixed time interval, no matter how many events occur.


The prototype chain is the mechanism by which JavaScript objects inherit features (properties and methods) from 
other objects.

devdatt --> person --> Object.prototype --> null
Each __proto__ points to a parent prototype, forming a chain until it reaches null.

const arr = [1, 2, 3];

console.log(arr.toString()); // Where is toString()?

// arr --> Array.prototype --> Object.prototype --> null

The prototype chain is how JavaScript looks up properties or methods by moving up a chain of linked objects through __proto__ ‚Äî enabling inheritance.


A shallow copy duplicates only the first level of the object or array.
If it contains nested objects, the nested parts are still referenced (not copied independently).

while in deep copy whole structure is cloned 

const original = {
  name: "Devdatt",
  address: { city: "Pune" }
};

const shallow = { ...original };

shallow.name = "Zorahi";
shallow.address.city = "Mumbai";

console.log(original.address.city); // üî• "Mumbai" ‚Äî changed!



const original = {
  name: "Devdatt",
  address: { city: "Pune" }
};

const deep = JSON.parse(JSON.stringify(original)); // Deep copy

deep.address.city = "Mumbai";

console.log(original.address.city); // ‚úÖ "Pune" ‚Äî original is safe



‚ÄúTop-level values are cloned‚Äù means the outer object and its direct properties 
are copied ‚Äî but in shallow copy, nested objects/arrays remain shared, while deep 
copy duplicates everything, including nested levels.


map() ‚Äî Transform Each Element

filter() ‚Äî Select Some Elements

reduce() ‚Äî Combine All Elements into One Value

forEach() ‚Äî Just Loop (No Return)


An IIFE is a JavaScript function that is defined and immediately executed after its creation.

An IIFE (Immediately Invoked Function Expression) is a function that runs as soon as it is defined ‚Äî 
useful for creating private scope, isolating variables, and running one-time setup code.

In the real world, IIFEs are like private rooms where you can do things without affecting or being 
affected by the outside world, helping to keep your variables safe and isolated.

How would you implement a custom event listener?

.on()	Registers one or more callbacks under a named event
.emit()	Calls all callbacks with optional data
.off()	Removes a specific callback from the event

The Virtual DOM is a lightweight copy (a virtual representation) of the 
real browser DOM, stored in memory.

Build a virtual representation of the UI.
Compare it with the previous version (called diffing).
Apply the minimal changes to the real DOM (called reconciliation).

The Virtual DOM allows batching, caching, and minimized real updates

The Virtual DOM is an in-memory JS representation of the real DOM; React uses it to detect changes 
efficiently and update the real DOM with minimal cost.

Reconciliation is the process React uses to update the real DOM when the state or 
props of a component change.

useReducer is a React Hook used for state management‚Äîjust like useState, 
but more structured, powerful, and scalable for complex logic.

It is ideal when state depends on previous state or when there are multiple 
actions that can change the state.

const [state, dispatch] = useReducer(reducerFunction, initialState);

reducerFunction: A function that takes current state and action and returns the new state.
initialState: The initial state of the component.
dispatch: A function to send actions to the reducer.

useReducer is needed when your component's state logic is complex, depends on previous state, or involves 
multiple related state updates. 


Toggling dark mode inside a component	        useState
Managing a counter with multiple actions	    useReducer
Sharing user data (name, token) across app	    Context API + useState or useReducer
Managing cart, auth, settings in large app	    Redux
Sharing theme globally + complex logic	        Context API + useReducer
Form with dependent fields in one component	    useReducer

useState is for simple local state,
useReducer is for complex local logic,
Context API is for global access and nested state,
Redux is for complex global state with structure and tools.


useEffect() is a React Hook that lets you run side effects in functional components ‚Äî such as fetching data, setting up subscriptions, manually changing the DOM, etc.

It replaces lifecycle methods like:

componentDidMount
componentDidUpdate
componentWillUnmount


A side effect is anything that affects the outside world, such as:

Fetching data from an API üåê
Subscribing to a WebSocket or event
Updating the DOM manually
Setting a timer ‚è∞


componentDidMount	    useEffect(() => {}, [])
componentDidUpdate	    useEffect(() => {}, [x])
componentWillUnmount	Cleanup function inside useEffect()

What causes infinite re-render in useEffect?

Infinite re-render happens when your useEffect triggers a state update that causes the component to 
re-render again and again, and that update keeps getting triggered on every render.

Golden Rule to Prevent Infinite Loops
‚úÖ Only include values in the dependency array that are stable, or memoize them with useCallback / useMemo
‚úÖ Avoid state updates inside useEffect unless they're conditional


useCallback(fn, deps)	    Caches a function
useMemo(fn, deps)	        Caches a computed value (result of a function)


In React, functions are re-created on every render. If you pass such a function to a 
child component or hook (like useEffect), it may cause unnecessary re-renders or re-executions.
‚úÖ Use useCallback to prevent function re-creation unless its dependencies change.

When to Use:

Passing functions as props to child components (to avoid re-renders)
Functions used inside useEffect as dependencies

You have a costly computation (like a loop or transformation), 
and you want to avoid recalculating it every render.
‚úÖ Use useMemo to cache the result of a function, 
so it's only recomputed when dependencies change.

When to Use:

Heavy calculations (e.g., sorting, filtering large arrays)
Derived values that are expensive to compute
Avoiding recomputation of derived values in render

Controlled	    You update a field in a Google Sheet ‚Üí auto-sync with backend (React controls everything)
Uncontrolled	You write something on paper ‚Üí look at it later when needed (DOM keeps value)

Prop drilling happens when you pass props through many layers of components, just to get data 
to a deeply nested child.

context api vs Redux 

dispatch({ type: 'INCREMENT' })
  ‚Üì
reducer(state, action)
  ‚Üì
new state returned ‚Üí store updated
  ‚Üì
components re-render

Context API:
When any value in a Context.Provider changes, all components that consume it re-render, 
even if they don‚Äôt need the specific part of the state that changed.

Redux:
Redux allows you to select only the exact part of state you want, and only components 
subscribed to that piece will re-render.

React Context causes all consumers to re-render when its value changes 
(even if not needed), while Redux allows fine-grained updates using selectors ‚Äî making 
Redux more efficient in large apps.

Middleware(redux thunk) is code that sits between dispatching an action and the moment it reaches the reducer.

It lets you intercept, modify, delay, log, or cancel actions.Imagine Redux store is a news channel, and useSelector() is like subscribing to just the sports section.
If politics or weather updates change, you don‚Äôt care ‚Äî you won‚Äôt be notified.

A Higher-Order Component is a function that adds extra behavior to a React component by wrapping it, helping reuse logic across multiple components.

// HOC Definition
function withTitle(title) {
  return function (Component) {
    return function (props) {
      useEffect(() => {
        document.title = title;
      }, []);
      return <Component {...props} />;
    };
  };
}

// Component
function Profile({ user }) {
  return <h1>Welcome, {user}</h1>;
}

// Apply HOC
const ProfileWithTitle = withTitle("User Profile")(Profile);

// Use in App
function App() {
  return <ProfileWithTitle user="Devdatt" />;
}

What is the Compound Components Pattern?

It‚Äôs a design pattern where multiple components work together as a single unit ‚Äî sharing implicit state and behavior, typically managed by a parent component.

The child components depend on the parent context, and not on direct props from each other.

use Cases in Real Life

UI Component	        Compound Children
<Tabs>	                <Tabs.List>, <Tabs.Trigger>, <Tabs.Panel>
<Accordion>             <Accordion.Item>, <Accordion.Header>, <Accordion.Body>
<Form>	                <Form.Input>, <Form.Label>, <Form.Error>
<Dropdown>	            <Dropdown.Button>, <Dropdown.Menu>, <Dropdown.Item>

‚öôÔ∏è Implementation Under the Hood

Uses React.createContext() to store shared state in the parent
Each compound child uses useContext() to access or manipulate that state
Props stay clean ‚Äî no drilling required
Composition is easy and declarative


A custom hook is a JavaScript function whose name starts with use, and it allows you to reuse stateful logic between components.

So instead of copying & pasting the same useState, useEffect, etc., logic into multiple components, you wrap that logic in a function ‚Äî a custom hook ‚Äî and use it like a built-in hook.

A custom hook is a reusable function that encapsulates React hook logic (useState, useEffect, etc.) to share behavior across components without repeating code.

import { useState, useEffect } from "react";

function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    function handleResize() {
      setWidth(window.innerWidth);
    }

    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return width;
}


function MyComponent() {
  const width = useWindowWidth();
  return <p>Window width: {width}px</p>;
}


Lazy loading is a technique where a component or resource is only loaded when it is needed, rather than at initial page load.


Think of a website like a building.
Eager loading builds all rooms up front ‚Äî even those users may never enter.
Lazy loading builds rooms on demand, only when the user opens the door.

Code splitting is the process of breaking your app‚Äôs JavaScript bundle into smaller chunks ‚Äî so that the browser loads only what's needed for the current view.

React supports this out of the box using:

React.lazy() for components
import() (dynamic import) for logic or libraries
Tools like Webpack or Vite handle the actual splitting


React.memo memoizes components to skip re-renders, while useMemo memoizes values to skip recalculations.

React.memo() works by storing the last props and using shallow comparison to skip rendering if props haven't changed ‚Äî optimizing performance for pure, stateless components.


const Child = React.memo(({ name }) => {
  console.log("Child rendered");
  return <p>Hello, {name}</p>;
});

function Parent() {
  const [count, setCount] = React.useState(0);

  return (
    <>
      <Child name="Devdatt" />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </>
  );
}


What Happens When You Click the Button?

Parent re-renders (because count changed)
Normally, Child would re-render too
But because Child is wrapped in React.memo(), and name="Devdatt" hasn‚Äôt changed,
React.memo skips the Child re-render, so "Child rendered" is not logged again


When should you use useRef?

useRef is a React hook that gives you a persistent, mutable object (ref.current) that doesn‚Äôt trigger a re-render when changed.

useRef gives you a mutable value that persists across renders but doesn't cause re-renders, perfect for DOM access, timers, and tracking values behind the scenes.


const timerRef = useRef(null);

function handleStart() {
  timerRef.current = setTimeout(() => {
    console.log("Finished!");
  }, 1000);
}

function handleCancel() {
  clearTimeout(timerRef.current);
}

An Error Boundary is a special React component that catches JavaScript errors in its child components and shows a fallback UI instead of crashing the app.

An Error Boundary is a special class component in React that catches rendering errors in its child tree and shows a fallback UI, preventing the entire app from crashing.

Important Gotchas

‚ö†Ô∏è Issue	                                                ‚öôÔ∏è Workaround
Doesn't work with functional components directly	        Wrap them inside class-based boundary

Doesn‚Äôt catch async errors	                                Use try-catch in fetch, setTimeout, etc.

Doesn‚Äôt log automatically	                                Manually log to Sentry, Firebase, etc.

No built-in error boundary in React functional API (yet)	Use class component for boundaries


Suspense is a built-in React component that lets you "pause rendering" of a part of your UI until something (like data or a lazy-loaded component) is ready ‚Äî while showing a fallback UI (like a spinner or skeleton).

Suspense lets React pause rendering and show fallback until lazy components or data are ready.

Concurrent Mode enables React to schedule and prioritize rendering, making apps smoother and more responsive.

In React 18+, you don‚Äôt need to turn on Concurrent Mode manually ‚Äî just use createRoot(), and React enables it automatically when you use concurrent features like useTransition, Suspense, etc.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~nextjs~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Term	    Full Form	                        Page is Generated...
SSR	        Server-Side Rendering	            üîÑ On every request
SSG	        Static Site Generation	            üèóÔ∏è At build time
ISR	        Incremental Static Regeneration	    ‚è±Ô∏è At runtime on-demand, then cached



getStaticProps: Fetch data once at build time ‚Äì for fast, cacheable static pages
getServerSideProps: Fetch data on each request ‚Äì for dynamic, up-to-date content
getInitialProps: Legacy hybrid method ‚Äì works for both server and client, but not recommended now


Dynamic routing in Next.js allows you to create pages with variable paths, where the URL contains parameters like an id, slug, or username.

| Pattern            | File                      | Example URL            |
| ------------------ | ------------------------- | ---------------------- |
| Single param       | `[id].js`                 | `/product/123`         |
| Nested routes      | `product/[id]/details.js` | `/product/123/details` |
| Catch-all          | `[...slug].js`            | `/docs/nextjs/routing` |
| Optional catch-all | `[[...slug]].js`          | `/docs` or `/docs/a/b` |


pages/
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ [...slug].js       ‚Üí /docs/a/b/c   ‚úÖ   | /docs ‚ùå
‚îÇ   ‚îú‚îÄ‚îÄ [[...slug]].js     ‚Üí /docs         ‚úÖ   | /docs/a ‚úÖ


 The structure of your pages/ folder automatically defines your app‚Äôs routes (URLs) ‚Äî no need for a router configuration file like in React Router.

 Your pages/ folder = your routing map

 Since Next.js 13+, you can use the /app directory (App Router)
This replaces the pages/ folder and gives you more control and flexibility, including:

| Feature                              | `pages/` Router (old)   | `app/` Router (new) |
| ------------------------------------ | ---------------------   | ------------------- |
| File-based routing                   | ‚úÖ Yes                 | ‚úÖ Yes               |
| Dynamic routing                      | ‚úÖ Yes                 | ‚úÖ Yes               |
| **Nested layouts / route grouping**  | ‚ùå No                  | ‚úÖ Yes               |
| **Colocation of components + logic** | ‚ùå No                  | ‚úÖ Yes               |
| React Server Components (RSC)        | ‚ùå No                  | ‚úÖ Yes               |
| Better parallel route control        | ‚ùå No                  | ‚úÖ Yes               |


React Server Components (RSC) are React components that run only on the server, never in the browser ‚Äî and they send only the rendered HTML (not JS) to the client.

| Type                 | Runs On        | Can Access DB/API? | Sent to Browser? |
| -------------------- | -------------- | ------------------ | ---------------- |
| **Client Component** | üß† Browser     | ‚ùå No               | ‚úÖ Yes (JS code)  |
| **Server Component** | üñ• Server only | ‚úÖ Yes              | ‚ùå No JS sent     |


why use server comp?
| Reason                      | Benefit                      |
| --------------------------- | ---------------------------- |
| Reduce JavaScript on client | Faster page load             |
| No need to write API routes | Direct access to server code |
| Better SEO                  | Pre-rendered content         |
| Cost-efficient rendering    | Only re-render what‚Äôs needed |

| Rule                                            | Explanation               |
| ----------------------------------------------- | ------------------------- |
| Server Components can import Client ones        | ‚úÖ Allowed                 |
| Client Components **can‚Äôt** import Server ones  | ‚ùå Not allowed             |
| Mark client components with `'use client'`      | At top of file            |
| Server Components only work in `/app` directory | Not available in `/pages` |



GraphQL : 



    Absolutely, Devdatt! Let's now focus on the **client-side** of GraphQL and answer your two questions:

    ---

    ### ‚úÖ Questions you asked:

    1. **How does the client build this GraphQL query?**
    2. **How does this query work under the hood from the client-side?**

    We‚Äôll answer both using **step-by-step explanation + pseudocode + actual frontend code**.

    ---

    # üí° The Query You Mentioned

    ```graphql
    query {
    user(id: "123") {
        name
        cart {
        items {
            name
            price
        }
        }
    }
    }
    ```

    This is a **GraphQL query string**, just like JSON but for requesting data.

    ---

    ## ‚öôÔ∏è 1. How Client Builds the Query (3 Approaches)

    ### üîπ Option 1: Raw fetch + query string (manual method)

    const query = `
    query {
        user(id: "123") {
        name
        cart {
            items {
            name
            price
            }
        }
        }
    }
    `;

    fetch("http://localhost:4000/graphql", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ query })
    })
    .then(res => res.json())
    .then(data => console.log(data));

    ‚úÖ This is the **most basic client-side way** to use GraphQL.


    ### üîπ Option 2: With Variables (recommended)

    const query = `
    query GetUser($id: ID!) {
        user(id: $id) {
        name
        cart {
            items {
            name
            price
            }
        }
        }
    }
    `;

    const variables = { id: "123" };

    fetch("http://localhost:4000/graphql", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ query, variables })
    })
    .then(res => res.json())
    .then(data => console.log(data));

    ‚úÖ This makes the query **reusable** by passing different variables.


    ### üîπ Option 3: With Apollo Client (framework)

    npm install @apollo/client graphql

    import { gql, useQuery } from "@apollo/client";

    const GET_USER = gql`
    query GetUser($id: ID!) {
        user(id: $id) {
        name
        cart {
            items {
            name
            price
            }
        }
        }
    }
    `;

    const CartPage = () => {
    const { loading, error, data } = useQuery(GET_USER, {
        variables: { id: "123" }
    });

    if (loading) return <p>Loading...</p>;
    if (error) return <p>Error!</p>;

    return (
        <div>
        <h1>{data.user.name}'s Cart</h1>
        {data.user.cart.items.map(item => (
            <p key={item.name}>{item.name} - ‚Çπ{item.price}</p>
        ))}
        </div>
    );
    };

    ‚úÖ This is the **real production setup** used by React/Next.js teams.

    ---

    üß† 2. How the Query Works on the Client Side (Under the Hood)

    Step-by-Step Behind the Scenes:

    ‚úÖ Step 1: You write the query string

    query {
    user(id: "123") {
        name
        cart {
        items {
            name
            price
        }
        }
    }
    }

    #### ‚úÖ Step 2: You send that to `/graphql` as `POST` with body:

    {
    "query": "...",
    "variables": { "id": "123" }
    }

    #### ‚úÖ Step 3: Browser makes HTTP request

    fetch("/graphql", { method: "POST", body: JSON.stringify({ query }) })

    #### ‚úÖ Step 4: Server receives query

    * Parses the GraphQL query string
    * Validates against schema
    * Calls appropriate resolver functions
    * Collects data
    * Returns it as JSON

    #### ‚úÖ Step 5: Client receives JSON

    {
    "data": {
        "user": {
        "name": "Devdatt",
        "cart": {
            "items": [
            { "name": "Sherwani", "price": 2500 },
            { "name": "Lehenga", "price": 3000 }
            ]
        }
        }
    }
    }

    #### ‚úÖ Step 6: You use the data in your UI

    <h1>{data.user.name}'s Cart</h1>


    ## üßæ Key Client-side Concepts

    | Concept             | Explanation                                                                  |
    | ------------------- | ---------------------------------------------------------------------------- |
    | `query` string      | GraphQL query written in a string format                                     |
    | `variables`         | Dynamic parameters like `id`, `limit`                                        |
    | `fetch` or Apollo   | Sends the query to the server                                                |
    | JSON response       | Returned by GraphQL server, shaped exactly like the query                    |
    | Apollo `useQuery()` | React hook to auto-fetch data, handle loading/error, and give you the result |

    ---

    ## ‚úÖ One-Line Summary:

    > The client builds a query string, sends it as a POST request to `/graphql`, and receives only the exact fields it asked for ‚Äî thanks to GraphQL's schema and resolver logic.

    ---


In Next.js, your pages/ folder acts like a map:
The file and folder names inside pages/ automatically become the URLs (routes) of your web app.

| File Name            | Matches URL         | router.query output       |
| -------------------- | ------------------- | ------------------------- |
| `[id].js`            | `/product/123`      | `{ id: "123" }`           |
| `user/[username].js` | `/user/devdatt`     | `{ username: "devdatt" }` |
| `post/[slug].js`     | `/post/hello-world` | `{ slug: "hello-world" }` |


In Next.js, implementing dynamic meta tags (like title, description, Open Graph tags, etc.) is essential for SEO, social sharing, and per-page customization.

getStaticPaths is a Next.js data-fetching function used with dynamic pages (like [slug].js) to tell Next.js which dynamic routes should be pre-rendered at build time.

getStaticPaths() is a Next.js function that works with getStaticProps() to pre-build specific dynamic routes (like product pages) at build time for better performance and SEO.

At build time, getStaticPaths() tells Next.js which slugs to pre-build, and for each of those, getStaticProps() fetches the data to render the final HTML ‚Äî together, they enable dynamic pages to be served as fast, static files.


import Head from 'next/head';

export default function ProductPage({ product }) {
  return (
    <>
      <Head>
        <title>{product.name} - Buy/Rent Now | Zorahi</title>
        <meta name="description" content={product.description.slice(0, 150)} />
        <meta property="og:image" content={product.image} />
        <link rel="canonical" href={`https://zorahi.com/product/${product.slug}`} />
      </Head>

      {/* Your product UI here */}
    </>
  );
}


 Canonical URL (<link rel="canonical" ... />)

 Why: It tells Google the primary source for this page's content, especially helpful if you have multiple URLs showing same product (like /product/lehenga and /outfits/lehenga).


SEO :- 

  mobile first apporach is a priority -> google's mobile-first indexing 
  core web vital -> website should load fast 
  backlinks -> links from other sites
  content relevance -> give Meaningful names to slugs 
  Schema Markup -> JSON-LD 


Product-level SEO means dynamically setting <title>, meta tags, OG tags, and JSON-LD schema per product in your eCommerce app ‚Äî so each product can rank and preview well individually.


| Concept           | Explanation                                                            |
| ----------------- | ---------------------------------------------------------------------- |
| `next/head`       | Adds custom tags to `<head>` of the document for the current page      |
| Dynamic meta tags | Done using `next/head` with dynamic data (e.g., from `getStaticProps`) |
| Per-page SEO      | Ensures each page (like products or blog posts) has unique meta info   |



getStaticProps() and getStaticPaths() only work in the pages/ router ‚Äî in the app/ router, use generateStaticParams() and server components for data fetching instead.


Server Component Data Fetching (replaces getStaticProps)
In App Router, you fetch data directly in the component:

// app/products/[slug]/page.tsx

export default async function ProductPage({ params }) {
  const product = await getProduct(params.slug);

  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
    </div>
  );
}

‚úÖ Fully server-rendered
‚úÖ No separate getStaticProps function
  


Middleware is a special function in Next.js that runs before a request is completed ‚Äî allowing you to rewrite, redirect, authenticate, or modify the request/response on the edge (i.e., before hitting your server or routes).


Edge Functions are serverless functions that run on the edge network (closer to the user) ‚Äî just like Vercel Functions or API routes, but executed globally, with minimal latency.


| Feature              | Middleware                                | Edge Function                            |
| -------------------- | ----------------------------------------- | ---------------------------------------- |
| üîÑ Purpose           | Modify request/response before routing    | Full API logic at the edge               |
| üß† Runs at...        | Before rendering a route                  | As a serverless function                 |
| üìÅ Defined in        | `middleware.ts` at root                   | Any `pages/api/*.ts` or custom           |
| üïê Use Cases         | Auth, redirect, rewrite                   | Real-time APIs, headers, personalization |
| ‚öôÔ∏è Access to request | ‚úÖ Yes                                     | ‚úÖ Yes                                    |
| üì§ Can send response | ‚úÖ Yes (via redirect/rewrite/NextResponse) | ‚úÖ Yes (as normal API response)           |


Middleware runs before your route loads ‚Äî used for redirects, auth, rewrites ‚Äî while Edge Functions are full serverless API handlers that run at the edge for ultra-fast logic and data handling.

Edge Functions are serverless functions that run on the edge network (closer to the user) ‚Äî just like Vercel Functions or API routes, but executed globally, with minimal latency.

An edge network is a global network of data centers (servers) that are physically located closer to the end users ‚Äî all around the world.


| Feature             | Edge Functions                        | CDN (Content Delivery Network)            |
| ------------------- | ------------------------------------- | ----------------------------------------- |
| üß† Purpose          | Run **custom logic** (code)           | Serve **static files** (HTML, JS, images) |
| üíª Runs Code?       | ‚úÖ Yes (JavaScript/TypeScript logic)   | ‚ùå No (only caches & delivers files)       |
| üèÉ Runtime          | V8 isolate (like serverless function) | Just a cache layer, no logic              |
| üì¶ Example Use Case | Auth, A/B test, dynamic rewrite       | Load CSS, images, and JS fast             |
| üåç Location         | Edge network (worldwide)              | Same ‚Äî edge network (worldwide)           |


A CDN is a warehouse that stores finished goods and delivers them fast.
An Edge Function is a smart mini-factory near the warehouse that can custom-make or modify the goods before delivery.

CDNs and Edge Functions often run on the same edge server ‚Äî the edge function runs custom logic first, then the CDN serves static content ‚Äî all close to the user for speed and flexibility.

next/link enables client-side navigation and preloading in Next.js, while a normal <a> tag triggers a full page reload ‚Äî losing all app state and performance benefits

Bonus: Prefetching Behavior
By default:

next/link preloads the page component when the link appears in the viewport or when hovered

Makes navigation feel instant

You can control it like:

<Link href="/about" prefetch={false}>About</Link>


Use _document.tsx to customize the static HTML structure (SSR only) and _app.tsx to add global layouts, providers, and logic to every page (CSR + SSR).


ctx stands for context, and it is an object passed into functions like:

getServerSideProps(ctx)
getInitialProps(ctx)
getStaticProps(ctx)
and Document.getInitialProps(ctx) (in _document.tsx)

ctx (context) is an object that contains everything Next.js knows about the current request ‚Äî like URL, query, cookies, params, etc. ‚Äî and is used in server-rendering and page setup functions.


export async function getServerSideProps(ctx) {
  const { req, res, params, query, resolvedUrl, locale } = ctx;
}

Property	Description
req	HTTP request object (like in Express)
res	HTTP response object
params	Route params like [id] from dynamic routes
query	Query string from URL (e.g. ?search=lehenga)
resolvedUrl	The full path requested
locale	Current locale (for i18n apps)


When would you use Context over Redux?

Use React Context for small, static global state (e.g., theme, auth status).
Use Redux for large, dynamic, deeply nested, shared state with complex updates or async logic.



 What problems does Redux solve?\

Centralized state management
Predictable state updates via reducers
Debuggable with time-travel tools
Scalable for large apps
Handles async actions via middleware


 What is Redux Toolkit and why is it preferred?

A modern wrapper over Redux that reduces boilerplate and adds best practices.

‚úÖ Benefits:

Simplified store setup
createSlice, createAsyncThunk
Built-in Immer for immutability
Devtools + middleware ready
Encourages best practices

Difference between useReducer and Redux?

Feature	        useReducer (React)	    Redux
Scope	          Local to one component	Global, app-wide
Middleware	      ‚ùå No	              ‚úÖ Yes (Thunk, Saga, etc.)
Devtools	        ‚ùå No	              ‚úÖ Yes
Async Support	    ‚ùå Manual	          ‚úÖ Built-in with middleware
Use Case	       Simple component state	Complex global state

How do you structure large-scale state in Redux?

Use Redux Toolkit
Split state into feature slices
Organize by feature: features/user/userSlice.ts
Use combineReducers() or configureStore()
Keep side effects in thunks or middleware

Explain middleware in Redux (e.g., Redux Thunk)

Middleware intercepts actions before they reach reducers ‚Äî used for logging, async calls, etc.
Thunk: lets you dispatch async logic (dispatch(fetchUser()))
Logger: logs actions/state for debugging
Custom: track analytics, auth, etc.

What is an action creator and reducer?

Action Creator: Function that returns an action

const addUser = (user) => ({ type: 'ADD_USER', payload: user });

Reducer: Pure function that updates state based on action type

function userReducer(state, action) {
  switch (action.type) {
    case 'ADD_USER': return [...state, action.payload];
  }
}


How do you persist Redux state across refresh?

Use redux-persist
It saves Redux state to localStorage or sessionStorage

import { persistStore, persistReducer } from 'redux-persist';


What are some alternatives to Redux?

| Alternative     | Use Case                      |
| --------------- | ----------------------------- |
| Zustand         | Lightweight, less boilerplate |
| Recoil          | Graph-like global state       |
| Jotai           | Primitive-based atomic state  |
| MobX            | Reactive observable state     |
| React Query/SWR | Async server-state caching    |


How does SWR / React Query help with caching?

They handle server state, not global app state.

Benefits:

Data fetching + caching out-of-the-box
Auto revalidation
Stale-while-revalidate strategy
Retry/focus/refetch on window focus
Great for APIs, pagination, mutations

React Query and SWR automatically cache and manage server-side data, making your UI fast, fresh, and resilient ‚Äî without needing Redux, loading states, or manual refetch logic.


How do you fetch data in React? Compare fetch and axios.

| Feature      | `fetch` (built-in)                     | `axios` (external lib)        |
| ------------ | -------------------------------------- | ----------------------------- |
| Syntax       | Verbose, manual parsing (`res.json()`) | Simple, returns JSON directly |
| Errors       | Doesn't throw on HTTP errors           | Throws on non-2xx responses   |
| Timeout      | Not built-in                           | Supports timeout              |
| Interceptors | ‚ùå No                                   | ‚úÖ Yes                         |
| File upload  | Manual `FormData` handling             | Easier with `axios.post()`    |


How do you cancel a request in Axios?

Use AbortController (Axios v1+) or CancelToken (v0.27):

const controller = new AbortController();
axios.get('/api/data', { signal: controller.signal });
controller.abort(); // cancels request

How can you debounce an API call?

Use setTimeout and clearTimeout:

useEffect(() => {
  const timer = setTimeout(() => {
    axios.get(`/api/search?q=${query}`);
  }, 500);

  return () => clearTimeout(timer);
}, [query]);

Or use lodash.debounce() or a custom debounce hook.

What is optimistic UI update?

Update the UI immediately as if the API call succeeded, then revert if it fails.

// optimistic update
setLikes(prev => prev + 1);

axios.post('/api/like').catch(() => {
  // rollback if failed
  setLikes(prev => prev - 1);
});

// optimistic update
setLikes(prev => prev + 1);

axios.post('/api/like').catch(() => {
  // rollback if failed
  setLikes(prev => prev - 1);
});


How do you cache API responses in the frontend?

| Method                | Description                          |
| --------------------- | ------------------------------------ |
| **React Query / SWR** | Built-in caching and background sync |
| **LocalStorage**      | Manual caching (e.g., on page load)  |
| **SessionStorage**    | Cache per tab/session                |
| **IndexedDB**         | Large offline data                   |


Storing a temporary copy of your data (pages, images, API responses)
so it can be delivered faster the next time it‚Äôs requested.

‚úÖ 1. What tools do you use to measure performance in React?

| Tool                        | Purpose                          |
| --------------------------- | -------------------------------- |
| **React DevTools Profiler** | Measures component render times  |
| **Chrome DevTools**         | Audit bundle size, layout, paint |
| **Lighthouse**              | Page performance + web vitals    |
| **Webpack Bundle Analyzer** | Visualizes JS bundle size        |
| **why-did-you-render**      | Logs unnecessary re-renders      |


Difference between Code Splitting and Tree Shaking

| Feature | Code Splitting                 | Tree Shaking                         |
| ------- | ------------------------------ | ------------------------------------ |
| Purpose | Split code into smaller chunks | Remove unused code from final bundle |
| When?   | At build or runtime            | During bundling                      |
| Example | `React.lazy`, dynamic import() | Unused functions/classes are removed |
| Tools   | Webpack, Vite                  | Terser, Webpack                      |


How can you reduce initial bundle size?

Use React.lazy() + Suspense
Split routes/components dynamically
Use tree-shakable libraries (e.g., lodash-es)
Avoid big libraries (moment.js ‚Üí date-fns)
Remove unused code and polyfills
Compress assets (gzip, Brotli)
Load fonts and styles async


What is React Profiler and how is it used?

A tab in React DevTools to analyze render performance.

‚úÖ It shows:

How long components took to render
What caused re-renders
Commit durations (slow components)

üì¶ Use <Profiler> in code for custom measurement:

<Profiler id="App" onRender={callbackFn}>
  <App />
</Profiler>


What are render-blocking resources?

Resources that delay the browser from rendering the page.

üü• Examples:

Synchronous JS <script> in <head>
Non-async CSS or fonts
Heavy blocking assets (images without lazy load)

‚úÖ Fix using:

defer or async on scripts
media or preload on styles/fonts
Lazy-load images and components

How would you optimize the re-renders in a React tree?

Use React.memo() to memoize components
Use useCallback and useMemo to avoid re-creating functions/values
Split large components
Avoid prop drilling (Context or Redux properly)
Minimize anonymous functions in JSX
Profile with React DevTools to find heavy renders

How do you defer offscreen content loading?

| Technique                          | Description                     |
| ---------------------------------- | ------------------------------- |
| `loading="lazy"`                   | On `<img>` and `<iframe>` tags  |
| `IntersectionObserver`             | Detect when elements enter view |
| `React.lazy` + Suspense            | Defer loading heavy components  |
| Virtualization (e.g. react-window) | Load only visible list items    |

 Prevents loading things user can‚Äôt see yet = faster page load.


‚úÖ 1. What is the role of Webpack/Babel in a frontend app?

| Tool        | Purpose                                                      |
| ----------- | ------------------------------------------------------------ |
| **Webpack** | Bundles JS, CSS, images into optimized static assets         |
| **Babel**   | Transpiles modern JS/JSX into backward-compatible code (ES5) |


‚úÖ 2. What is the purpose of a .babelrc file?

Config file to define Babel presets and plugins.

{
  "presets": ["@babel/preset-env", "@babel/preset-react"]
}


‚úÖ 3. Explain how transpiling works in modern apps.

Converts modern JavaScript (ES6+) into older versions that browsers understand (ES5).
Babel reads code ‚Üí applies plugins ‚Üí outputs browser-safe code.


‚úÖ 4. What is a monorepo? Tools used to manage it?
A single repo that contains multiple projects/packages.

‚úÖ Tools:

Turborepo
Nx
Lerna
Yarn Workspaces

‚úÖ 5. What is tree shaking?

Removes unused imports from final JavaScript bundles.

‚úÖ Done during bundling (e.g., by Webpack + Terser) to reduce bundle size.


‚úÖ 6. Explain CORS and how to handle it.

Cross-Origin Resource Sharing: A security rule in browsers that blocks API calls to different origins unless explicitly allowed.

‚úÖ Fix: On server, add headers like:

Access-Control-Allow-Origin: *

Or restrict to your domain.


‚úÖ 7. What is a Service Worker? How is it used?

A background JS file that intercepts network requests, caches assets, and enables offline capabilities.

Used in:

PWAs
Background sync
Push notifications

‚úÖ 8. Explain PWA and its advantages.
Progressive Web App = Web app that feels like a native mobile app.

‚úÖ Benefits:

Offline support (via service worker)
Add to Home Screen
Push notifications
Fast load times (caching)
No app store needed

‚úÖ 10. Accessibility: what are ARIA roles?
ARIA (Accessible Rich Internet Applications) roles help screen readers interpret UI components.

Examples:

role="button" for custom div buttons
role="dialog" for modals
aria-label, aria-expanded for extra context

‚úÖ 11. SEO best practices in Next.js?

Use next/head for meta tags
Use getStaticProps or getServerSideProps for SEO content
Generate sitemap and robots.txt
Use semantic HTML (<main>, <article>, etc.)
Implement structured data (schema.org JSON-LD)
Optimize images (next/image)


‚úÖ 12. Difference between hydration and rehydration?

| Term            | Meaning                                                                                             |
| --------------- | --------------------------------------------------------------------------------------------------- |
| **Hydration**   | React attaching event listeners to server-rendered HTML (on first page load)                        |
| **Rehydration** | (Less common term) Sometimes used interchangeably, or to describe reattaching state after cache/SSR |


What is a Service Worker?

A Service Worker is a special type of JavaScript file that runs in the background of your browser, separate from the main webpage.
It does not have access to the DOM directly, but it can:

Intercept network requests
Cache files for offline use
Push background notifications
Improve load speed (by serving from cache)

It acts like a proxy between your app and the network.