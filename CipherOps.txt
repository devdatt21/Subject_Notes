What are semantic HTML tags and why are they important?

Meaningful structure	Easier to read and understand
Accessibility	        Helps screen readers and assistive tech
SEO	                    Helps search engines interpret content more accurately
Maintainability	        Easy to maintain, update, and scale


Difference between <section>, <article>, and <div>?

<div>	    Plain cardboard box (no label)      no use in SEO 
<section>	Labeled box with grouped items      slightly use in SEO 
<article>	A single complete book or magazine  very useful in SEO 


How does the CSS specificity hierarchy work?

Inline styles > IDs > Classes > Elements


What is the difference between em, rem, %, and px?

px ‚Üí Absolute unit; always the same fixed size regardless of anything else.

% ‚Üí Relative to the parent's size (width/height or font-size depending on the property).

em ‚Üí Relative to the element‚Äôs own font-size, which may be inherited or explicitly set.

rem ‚Üí Relative to the root (<html>) font-size, providing consistent scaling across the page.\\\


Flexbox vs Grid ‚Äì when to use each?

you should use both grid and flexbox in a page 
    grid is like a structure of a page 
    flex is like a structure of a row

    flex-direction	Main	Container	Set layout direction (row or column)
    justify-content	Main	Container	Align/space items on main axis
    align-items	    Cross	Container	Align all items on cross axis
    flex-wrap	    N/A	    Container	Allow items to wrap
    flex-grow	    Main	Item	    Control growth when extra space exists
    flex-shrink	    Main	Item	    Control shrink when space is tight
    flex-basis	    Main	Item	    Set initial/preferred size
    align-self	    Cross	Item	    Align one item differently


What is the difference between absolute, relative, fixed, and sticky positioning?

Feature	                static	relative	absolute	fixed	sticky
Takes up space	        ‚úÖ	    ‚úÖ	    ‚ùå	        ‚ùå	    ‚úÖ
Removed from flow	    ‚ùå	    ‚ùå	    ‚úÖ	        ‚úÖ	    ‚ùå
Scrolls with page	    ‚úÖ	    ‚úÖ	    ‚ùå	        ‚ùå	    ‚úÖ/‚ùå
Parent reference	    N/A	    Self	    Nearest  	Viewport	Scroll container
                                            positioned
                                            ancestor


Explain reflow vs repaint.

Reflow	Browser recalculates layout (sizes, positions) ‚Äî expensive
Repaint	Browser redraws visuals (color, shadows) ‚Äî lighter


What is Critical CSS and how can it improve performance?

Critical CSS is the minimum CSS needed to render above-the-fold content quickly 
‚Äî it boosts page speed, SEO, and user experience by reducing render-blocking.


What Are Web Vitals?

Web Vitals are a set of metrics defined by Google to measure the real-world \
performance of a webpage ‚Äî especially user experience.


3 core web vitals 
    LCP - largest contentful page 
    FID - first input delay 
    CLS - cumulative layout shift


How do media queries work?

Media queries let you apply CSS conditionally based on device or screen properties 
(like width, orientation, resolution) ‚Äî essential for making responsive websites.


What is z-index and how does stacking context work?

The z-index in CSS controls the stacking order of elements along the z-axis (depth) 
‚Äî i.e., which element appears in front of or behind another.

A stacking context is a local environment that controls how child elements are 
stacked inside it, independently of the rest of the page.

üîê Children are bound by the rules of their parent stacking context.




~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~js~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Hoisting is JavaScript's default behavior of moving declarations to the top of their 
scope during the compile phase (before the code runs).


var	                                ‚úÖ Yes	undefined	Function-scoped, can be re-declared
let & const	                        ‚úÖ Yes	‚ùå          Not initialized	Exists in Temporal Dead Zone
function	                        ‚úÖ   Yes	‚úÖ          Fully hoisted	Can call before definition
arrow function (const x = () => {})	‚ùå No	‚ùå          Not hoisted	Treated as variable


var	    Function-scoped, hoisted, can be re-declared ‚Üí legacy use
let	    Block-scoped, hoisted (TDZ), reassignable ‚Üí modern variable
const	Block-scoped, hoisted (TDZ), no reassignment ‚Üí use for constants


== compares values after converting types (loose equality), while === compares both value and type without 
conversion (strict equality) ‚Äî always prefer ===.

A closure is a function that remembers its outer lexical scope even after the outer function has finished executing.

Yes, closures in JavaScript often mimic or support OOP principles, even though closures themselves are 
not OOP-specific constructs.

JavaScript can only do one thing at a time ‚Äî it has one main thread where all code runs.


Call Stack	                Runs your actual code ‚Äî handles function calls (LIFO: last-in-first-out)
Web APIs	                Browser-provided features (setTimeout, DOM, fetch, etc.)
Callback Queue (Task Queue)	Stores callback functions waiting to run
Event Loop	                Keeps checking if the stack is empty, then pushes queued tasks


The call stack executes your code, the event loop keeps watching it, and async callbacks 
(via Web APIs) are queued and pushed onto the stack only when it‚Äôs empty ‚Äî making JavaScript 
non-blocking and fast.


A Promise is a JavaScript object that represents the eventual result (or failure) of an asynchronous operation.

async/await is for more complex logic while .then and .catch are more for simpler logic


Debouncing	Group a burst of events into one execution after a delay
Throttling	Ensure a function is called at most once every X ms, no matter how many times the event fires

Debouncing delays function execution until after a pause in events,
while throttling ensures the function runs at most once in a fixed time interval, no matter how many events occur.


The prototype chain is the mechanism by which JavaScript objects inherit features (properties and methods) from 
other objects.

devdatt --> person --> Object.prototype --> null
Each __proto__ points to a parent prototype, forming a chain until it reaches null.

const arr = [1, 2, 3];

console.log(arr.toString()); // Where is toString()?

// arr --> Array.prototype --> Object.prototype --> null

The prototype chain is how JavaScript looks up properties or methods by moving up a chain of linked objects through __proto__ ‚Äî enabling inheritance.


A shallow copy duplicates only the first level of the object or array.
If it contains nested objects, the nested parts are still referenced (not copied independently).

while in deep copy whole structure is cloned 

const original = {
  name: "Devdatt",
  address: { city: "Pune" }
};

const shallow = { ...original };

shallow.name = "Zorahi";
shallow.address.city = "Mumbai";

console.log(original.address.city); // üî• "Mumbai" ‚Äî changed!



const original = {
  name: "Devdatt",
  address: { city: "Pune" }
};

const deep = JSON.parse(JSON.stringify(original)); // Deep copy

deep.address.city = "Mumbai";

console.log(original.address.city); // ‚úÖ "Pune" ‚Äî original is safe



‚ÄúTop-level values are cloned‚Äù means the outer object and its direct properties 
are copied ‚Äî but in shallow copy, nested objects/arrays remain shared, while deep 
copy duplicates everything, including nested levels.


map() ‚Äî Transform Each Element

filter() ‚Äî Select Some Elements

reduce() ‚Äî Combine All Elements into One Value

forEach() ‚Äî Just Loop (No Return)


An IIFE is a JavaScript function that is defined and immediately executed after its creation.

An IIFE (Immediately Invoked Function Expression) is a function that runs as soon as it is defined ‚Äî 
useful for creating private scope, isolating variables, and running one-time setup code.

In the real world, IIFEs are like private rooms where you can do things without affecting or being 
affected by the outside world, helping to keep your variables safe and isolated.

How would you implement a custom event listener?

.on()	Registers one or more callbacks under a named event
.emit()	Calls all callbacks with optional data
.off()	Removes a specific callback from the event

The Virtual DOM is a lightweight copy (a virtual representation) of the 
real browser DOM, stored in memory.

Build a virtual representation of the UI.
Compare it with the previous version (called diffing).
Apply the minimal changes to the real DOM (called reconciliation).

The Virtual DOM allows batching, caching, and minimized real updates

The Virtual DOM is an in-memory JS representation of the real DOM; React uses it to detect changes 
efficiently and update the real DOM with minimal cost.

Reconciliation is the process React uses to update the real DOM when the state or 
props of a component change.

useReducer is a React Hook used for state management‚Äîjust like useState, 
but more structured, powerful, and scalable for complex logic.

It is ideal when state depends on previous state or when there are multiple 
actions that can change the state.

const [state, dispatch] = useReducer(reducerFunction, initialState);

reducerFunction: A function that takes current state and action and returns the new state.
initialState: The initial state of the component.
dispatch: A function to send actions to the reducer.

useReducer is needed when your component's state logic is complex, depends on previous state, or involves 
multiple related state updates. 


Toggling dark mode inside a component	        useState
Managing a counter with multiple actions	    useReducer
Sharing user data (name, token) across app	    Context API + useState or useReducer
Managing cart, auth, settings in large app	    Redux
Sharing theme globally + complex logic	        Context API + useReducer
Form with dependent fields in one component	    useReducer

useState is for simple local state,
useReducer is for complex local logic,
Context API is for global access and nested state,
Redux is for complex global state with structure and tools.


useEffect() is a React Hook that lets you run side effects in functional components ‚Äî such as fetching data, setting up subscriptions, manually changing the DOM, etc.

It replaces lifecycle methods like:

componentDidMount
componentDidUpdate
componentWillUnmount


A side effect is anything that affects the outside world, such as:

Fetching data from an API üåê
Subscribing to a WebSocket or event
Updating the DOM manually
Setting a timer ‚è∞


componentDidMount	    useEffect(() => {}, [])
componentDidUpdate	    useEffect(() => {}, [x])
componentWillUnmount	Cleanup function inside useEffect()

What causes infinite re-render in useEffect?

Infinite re-render happens when your useEffect triggers a state update that causes the component to 
re-render again and again, and that update keeps getting triggered on every render.

Golden Rule to Prevent Infinite Loops
‚úÖ Only include values in the dependency array that are stable, or memoize them with useCallback / useMemo
‚úÖ Avoid state updates inside useEffect unless they're conditional


useCallback(fn, deps)	    Caches a function
useMemo(fn, deps)	        Caches a computed value (result of a function)


In React, functions are re-created on every render. If you pass such a function to a 
child component or hook (like useEffect), it may cause unnecessary re-renders or re-executions.
‚úÖ Use useCallback to prevent function re-creation unless its dependencies change.

When to Use:

Passing functions as props to child components (to avoid re-renders)
Functions used inside useEffect as dependencies

You have a costly computation (like a loop or transformation), 
and you want to avoid recalculating it every render.
‚úÖ Use useMemo to cache the result of a function, 
so it's only recomputed when dependencies change.

When to Use:

Heavy calculations (e.g., sorting, filtering large arrays)
Derived values that are expensive to compute
Avoiding recomputation of derived values in render

Controlled	    You update a field in a Google Sheet ‚Üí auto-sync with backend (React controls everything)
Uncontrolled	You write something on paper ‚Üí look at it later when needed (DOM keeps value)

Prop drilling happens when you pass props through many layers of components, just to get data 
to a deeply nested child.

context api vs Redux 

dispatch({ type: 'INCREMENT' })
  ‚Üì
reducer(state, action)
  ‚Üì
new state returned ‚Üí store updated
  ‚Üì
components re-render

Context API:
When any value in a Context.Provider changes, all components that consume it re-render, 
even if they don‚Äôt need the specific part of the state that changed.

Redux:
Redux allows you to select only the exact part of state you want, and only components 
subscribed to that piece will re-render.

React Context causes all consumers to re-render when its value changes 
(even if not needed), while Redux allows fine-grained updates using selectors ‚Äî making 
Redux more efficient in large apps.

Middleware(redux thunk) is code that sits between dispatching an action and the moment it reaches the reducer.

It lets you intercept, modify, delay, log, or cancel actions.Imagine Redux store is a news channel, and useSelector() is like subscribing to just the sports section.
If politics or weather updates change, you don‚Äôt care ‚Äî you won‚Äôt be notified.

A Higher-Order Component is a function that adds extra behavior to a React component by wrapping it, helping reuse logic across multiple components.

// HOC Definition
function withTitle(title) {
  return function (Component) {
    return function (props) {
      useEffect(() => {
        document.title = title;
      }, []);
      return <Component {...props} />;
    };
  };
}

// Component
function Profile({ user }) {
  return <h1>Welcome, {user}</h1>;
}

// Apply HOC
const ProfileWithTitle = withTitle("User Profile")(Profile);

// Use in App
function App() {
  return <ProfileWithTitle user="Devdatt" />;
}

What is the Compound Components Pattern?

It‚Äôs a design pattern where multiple components work together as a single unit ‚Äî sharing implicit state and behavior, typically managed by a parent component.

The child components depend on the parent context, and not on direct props from each other.

use Cases in Real Life

UI Component	        Compound Children
<Tabs>	                <Tabs.List>, <Tabs.Trigger>, <Tabs.Panel>
<Accordion>             <Accordion.Item>, <Accordion.Header>, <Accordion.Body>
<Form>	                <Form.Input>, <Form.Label>, <Form.Error>
<Dropdown>	            <Dropdown.Button>, <Dropdown.Menu>, <Dropdown.Item>

‚öôÔ∏è Implementation Under the Hood

Uses React.createContext() to store shared state in the parent
Each compound child uses useContext() to access or manipulate that state
Props stay clean ‚Äî no drilling required
Composition is easy and declarative


A custom hook is a JavaScript function whose name starts with use, and it allows you to reuse stateful logic between components.

So instead of copying & pasting the same useState, useEffect, etc., logic into multiple components, you wrap that logic in a function ‚Äî a custom hook ‚Äî and use it like a built-in hook.

A custom hook is a reusable function that encapsulates React hook logic (useState, useEffect, etc.) to share behavior across components without repeating code.

import { useState, useEffect } from "react";

function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    function handleResize() {
      setWidth(window.innerWidth);
    }

    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return width;
}


function MyComponent() {
  const width = useWindowWidth();
  return <p>Window width: {width}px</p>;
}


Lazy loading is a technique where a component or resource is only loaded when it is needed, rather than at initial page load.


Think of a website like a building.
Eager loading builds all rooms up front ‚Äî even those users may never enter.
Lazy loading builds rooms on demand, only when the user opens the door.

Code splitting is the process of breaking your app‚Äôs JavaScript bundle into smaller chunks ‚Äî so that the browser loads only what's needed for the current view.

React supports this out of the box using:

React.lazy() for components
import() (dynamic import) for logic or libraries
Tools like Webpack or Vite handle the actual splitting


React.memo memoizes components to skip re-renders, while useMemo memoizes values to skip recalculations.

React.memo() works by storing the last props and using shallow comparison to skip rendering if props haven't changed ‚Äî optimizing performance for pure, stateless components.


const Child = React.memo(({ name }) => {
  console.log("Child rendered");
  return <p>Hello, {name}</p>;
});

function Parent() {
  const [count, setCount] = React.useState(0);

  return (
    <>
      <Child name="Devdatt" />
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </>
  );
}


What Happens When You Click the Button?

Parent re-renders (because count changed)
Normally, Child would re-render too
But because Child is wrapped in React.memo(), and name="Devdatt" hasn‚Äôt changed,
React.memo skips the Child re-render, so "Child rendered" is not logged again


When should you use useRef?

useRef is a React hook that gives you a persistent, mutable object (ref.current) that doesn‚Äôt trigger a re-render when changed.

useRef gives you a mutable value that persists across renders but doesn't cause re-renders, perfect for DOM access, timers, and tracking values behind the scenes.


const timerRef = useRef(null);

function handleStart() {
  timerRef.current = setTimeout(() => {
    console.log("Finished!");
  }, 1000);
}

function handleCancel() {
  clearTimeout(timerRef.current);
}

An Error Boundary is a special React component that catches JavaScript errors in its child components and shows a fallback UI instead of crashing the app.

An Error Boundary is a special class component in React that catches rendering errors in its child tree and shows a fallback UI, preventing the entire app from crashing.

Important Gotchas

‚ö†Ô∏è Issue	                                                ‚öôÔ∏è Workaround
Doesn't work with functional components directly	        Wrap them inside class-based boundary

Doesn‚Äôt catch async errors	                                Use try-catch in fetch, setTimeout, etc.

Doesn‚Äôt log automatically	                                Manually log to Sentry, Firebase, etc.

No built-in error boundary in React functional API (yet)	Use class component for boundaries


Suspense is a built-in React component that lets you "pause rendering" of a part of your UI until something (like data or a lazy-loaded component) is ready ‚Äî while showing a fallback UI (like a spinner or skeleton).

Suspense lets React pause rendering and show fallback until lazy components or data are ready.

Concurrent Mode enables React to schedule and prioritize rendering, making apps smoother and more responsive.

In React 18+, you don‚Äôt need to turn on Concurrent Mode manually ‚Äî just use createRoot(), and React enables it automatically when you use concurrent features like useTransition, Suspense, etc.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~nextjs~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Term	    Full Form	                        Page is Generated...
SSR	        Server-Side Rendering	            üîÑ On every request
SSG	        Static Site Generation	            üèóÔ∏è At build time
ISR	        Incremental Static Regeneration	    ‚è±Ô∏è At runtime on-demand, then cached



getStaticProps: Fetch data once at build time ‚Äì for fast, cacheable static pages
getServerSideProps: Fetch data on each request ‚Äì for dynamic, up-to-date content
getInitialProps: Legacy hybrid method ‚Äì works for both server and client, but not recommended now


Dynamic routing in Next.js allows you to create pages with variable paths, where the URL contains parameters like an id, slug, or username.

| Pattern            | File                      | Example URL            |
| ------------------ | ------------------------- | ---------------------- |
| Single param       | `[id].js`                 | `/product/123`         |
| Nested routes      | `product/[id]/details.js` | `/product/123/details` |
| Catch-all          | `[...slug].js`            | `/docs/nextjs/routing` |
| Optional catch-all | `[[...slug]].js`          | `/docs` or `/docs/a/b` |


pages/
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ [...slug].js       ‚Üí /docs/a/b/c   ‚úÖ   | /docs ‚ùå
‚îÇ   ‚îú‚îÄ‚îÄ [[...slug]].js     ‚Üí /docs         ‚úÖ   | /docs/a ‚úÖ


 The structure of your pages/ folder automatically defines your app‚Äôs routes (URLs) ‚Äî no need for a router configuration file like in React Router.

 Your pages/ folder = your routing map

 Since Next.js 13+, you can use the /app directory (App Router)
This replaces the pages/ folder and gives you more control and flexibility, including:

| Feature                              | `pages/` Router (old)   | `app/` Router (new) |
| ------------------------------------ | ---------------------   | ------------------- |
| File-based routing                   | ‚úÖ Yes                 | ‚úÖ Yes               |
| Dynamic routing                      | ‚úÖ Yes                 | ‚úÖ Yes               |
| **Nested layouts / route grouping**  | ‚ùå No                  | ‚úÖ Yes               |
| **Colocation of components + logic** | ‚ùå No                  | ‚úÖ Yes               |
| React Server Components (RSC)        | ‚ùå No                  | ‚úÖ Yes               |
| Better parallel route control        | ‚ùå No                  | ‚úÖ Yes               |


React Server Components (RSC) are React components that run only on the server, never in the browser ‚Äî and they send only the rendered HTML (not JS) to the client.

| Type                 | Runs On        | Can Access DB/API? | Sent to Browser? |
| -------------------- | -------------- | ------------------ | ---------------- |
| **Client Component** | üß† Browser     | ‚ùå No               | ‚úÖ Yes (JS code)  |
| **Server Component** | üñ• Server only | ‚úÖ Yes              | ‚ùå No JS sent     |


why use server comp?
| Reason                      | Benefit                      |
| --------------------------- | ---------------------------- |
| Reduce JavaScript on client | Faster page load             |
| No need to write API routes | Direct access to server code |
| Better SEO                  | Pre-rendered content         |
| Cost-efficient rendering    | Only re-render what‚Äôs needed |

| Rule                                            | Explanation               |
| ----------------------------------------------- | ------------------------- |
| Server Components can import Client ones        | ‚úÖ Allowed                 |
| Client Components **can‚Äôt** import Server ones  | ‚ùå Not allowed             |
| Mark client components with `'use client'`      | At top of file            |
| Server Components only work in `/app` directory | Not available in `/pages` |



GraphQL : 



    Absolutely, Devdatt! Let's now focus on the **client-side** of GraphQL and answer your two questions:

    ---

    ### ‚úÖ Questions you asked:

    1. **How does the client build this GraphQL query?**
    2. **How does this query work under the hood from the client-side?**

    We‚Äôll answer both using **step-by-step explanation + pseudocode + actual frontend code**.

    ---

    # üí° The Query You Mentioned

    ```graphql
    query {
    user(id: "123") {
        name
        cart {
        items {
            name
            price
        }
        }
    }
    }
    ```

    This is a **GraphQL query string**, just like JSON but for requesting data.

    ---

    ## ‚öôÔ∏è 1. How Client Builds the Query (3 Approaches)

    ### üîπ Option 1: Raw fetch + query string (manual method)

    const query = `
    query {
        user(id: "123") {
        name
        cart {
            items {
            name
            price
            }
        }
        }
    }
    `;

    fetch("http://localhost:4000/graphql", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ query })
    })
    .then(res => res.json())
    .then(data => console.log(data));

    ‚úÖ This is the **most basic client-side way** to use GraphQL.


    ### üîπ Option 2: With Variables (recommended)

    const query = `
    query GetUser($id: ID!) {
        user(id: $id) {
        name
        cart {
            items {
            name
            price
            }
        }
        }
    }
    `;

    const variables = { id: "123" };

    fetch("http://localhost:4000/graphql", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ query, variables })
    })
    .then(res => res.json())
    .then(data => console.log(data));

    ‚úÖ This makes the query **reusable** by passing different variables.


    ### üîπ Option 3: With Apollo Client (framework)

    npm install @apollo/client graphql

    import { gql, useQuery } from "@apollo/client";

    const GET_USER = gql`
    query GetUser($id: ID!) {
        user(id: $id) {
        name
        cart {
            items {
            name
            price
            }
        }
        }
    }
    `;

    const CartPage = () => {
    const { loading, error, data } = useQuery(GET_USER, {
        variables: { id: "123" }
    });

    if (loading) return <p>Loading...</p>;
    if (error) return <p>Error!</p>;

    return (
        <div>
        <h1>{data.user.name}'s Cart</h1>
        {data.user.cart.items.map(item => (
            <p key={item.name}>{item.name} - ‚Çπ{item.price}</p>
        ))}
        </div>
    );
    };

    ‚úÖ This is the **real production setup** used by React/Next.js teams.

    ---

    üß† 2. How the Query Works on the Client Side (Under the Hood)

    Step-by-Step Behind the Scenes:

    ‚úÖ Step 1: You write the query string

    query {
    user(id: "123") {
        name
        cart {
        items {
            name
            price
        }
        }
    }
    }

    #### ‚úÖ Step 2: You send that to `/graphql` as `POST` with body:

    {
    "query": "...",
    "variables": { "id": "123" }
    }

    #### ‚úÖ Step 3: Browser makes HTTP request

    fetch("/graphql", { method: "POST", body: JSON.stringify({ query }) })

    #### ‚úÖ Step 4: Server receives query

    * Parses the GraphQL query string
    * Validates against schema
    * Calls appropriate resolver functions
    * Collects data
    * Returns it as JSON

    #### ‚úÖ Step 5: Client receives JSON

    {
    "data": {
        "user": {
        "name": "Devdatt",
        "cart": {
            "items": [
            { "name": "Sherwani", "price": 2500 },
            { "name": "Lehenga", "price": 3000 }
            ]
        }
        }
    }
    }

    #### ‚úÖ Step 6: You use the data in your UI

    <h1>{data.user.name}'s Cart</h1>


    ## üßæ Key Client-side Concepts

    | Concept             | Explanation                                                                  |
    | ------------------- | ---------------------------------------------------------------------------- |
    | `query` string      | GraphQL query written in a string format                                     |
    | `variables`         | Dynamic parameters like `id`, `limit`                                        |
    | `fetch` or Apollo   | Sends the query to the server                                                |
    | JSON response       | Returned by GraphQL server, shaped exactly like the query                    |
    | Apollo `useQuery()` | React hook to auto-fetch data, handle loading/error, and give you the result |

    ---

    ## ‚úÖ One-Line Summary:

    > The client builds a query string, sends it as a POST request to `/graphql`, and receives only the exact fields it asked for ‚Äî thanks to GraphQL's schema and resolver logic.

    ---


In Next.js, your pages/ folder acts like a map:
The file and folder names inside pages/ automatically become the URLs (routes) of your web app.

| File Name            | Matches URL         | router.query output       |
| -------------------- | ------------------- | ------------------------- |
| `[id].js`            | `/product/123`      | `{ id: "123" }`           |
| `user/[username].js` | `/user/devdatt`     | `{ username: "devdatt" }` |
| `post/[slug].js`     | `/post/hello-world` | `{ slug: "hello-world" }` |


In Next.js, implementing dynamic meta tags (like title, description, Open Graph tags, etc.) is essential for SEO, social sharing, and per-page customization.

getStaticPaths is a Next.js data-fetching function used with dynamic pages (like [slug].js) to tell Next.js which dynamic routes should be pre-rendered at build time.

getStaticPaths() is a Next.js function that works with getStaticProps() to pre-build specific dynamic routes (like product pages) at build time for better performance and SEO.

At build time, getStaticPaths() tells Next.js which slugs to pre-build, and for each of those, getStaticProps() fetches the data to render the final HTML ‚Äî together, they enable dynamic pages to be served as fast, static files.


import Head from 'next/head';

export default function ProductPage({ product }) {
  return (
    <>
      <Head>
        <title>{product.name} - Buy/Rent Now | Zorahi</title>
        <meta name="description" content={product.description.slice(0, 150)} />
        <meta property="og:image" content={product.image} />
        <link rel="canonical" href={`https://zorahi.com/product/${product.slug}`} />
      </Head>

      {/* Your product UI here */}
    </>
  );
}


 Canonical URL (<link rel="canonical" ... />)

 Why: It tells Google the primary source for this page's content, especially helpful if you have multiple URLs showing same product (like /product/lehenga and /outfits/lehenga).


SEO :- 

  mobile first apporach is a priority -> google's mobile-first indexing 
  core web vital -> website should load fast 
  backlinks -> links from other sites
  content relevance -> give Meaningful names to slugs 
  Schema Markup -> JSON-LD 


Product-level SEO means dynamically setting <title>, meta tags, OG tags, and JSON-LD schema per product in your eCommerce app ‚Äî so each product can rank and preview well individually.


| Concept           | Explanation                                                            |
| ----------------- | ---------------------------------------------------------------------- |
| `next/head`       | Adds custom tags to `<head>` of the document for the current page      |
| Dynamic meta tags | Done using `next/head` with dynamic data (e.g., from `getStaticProps`) |
| Per-page SEO      | Ensures each page (like products or blog posts) has unique meta info   |



getStaticProps() and getStaticPaths() only work in the pages/ router ‚Äî in the app/ router, use generateStaticParams() and server components for data fetching instead.


Server Component Data Fetching (replaces getStaticProps)
In App Router, you fetch data directly in the component:

// app/products/[slug]/page.tsx

export default async function ProductPage({ params }) {
  const product = await getProduct(params.slug);

  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
    </div>
  );
}

‚úÖ Fully server-rendered
‚úÖ No separate getStaticProps function
  


Middleware is a special function in Next.js that runs before a request is completed ‚Äî allowing you to rewrite, redirect, authenticate, or modify the request/response on the edge (i.e., before hitting your server or routes).


Edge Functions are serverless functions that run on the edge network (closer to the user) ‚Äî just like Vercel Functions or API routes, but executed globally, with minimal latency.


| Feature              | Middleware                                | Edge Function                            |
| -------------------- | ----------------------------------------- | ---------------------------------------- |
| üîÑ Purpose           | Modify request/response before routing    | Full API logic at the edge               |
| üß† Runs at...        | Before rendering a route                  | As a serverless function                 |
| üìÅ Defined in        | `middleware.ts` at root                   | Any `pages/api/*.ts` or custom           |
| üïê Use Cases         | Auth, redirect, rewrite                   | Real-time APIs, headers, personalization |
| ‚öôÔ∏è Access to request | ‚úÖ Yes                                     | ‚úÖ Yes                                    |
| üì§ Can send response | ‚úÖ Yes (via redirect/rewrite/NextResponse) | ‚úÖ Yes (as normal API response)           |


Middleware runs before your route loads ‚Äî used for redirects, auth, rewrites ‚Äî while Edge Functions are full serverless API handlers that run at the edge for ultra-fast logic and data handling.

Edge Functions are serverless functions that run on the edge network (closer to the user) ‚Äî just like Vercel Functions or API routes, but executed globally, with minimal latency.

An edge network is a global network of data centers (servers) that are physically located closer to the end users ‚Äî all around the world.


| Feature             | Edge Functions                        | CDN (Content Delivery Network)            |
| ------------------- | ------------------------------------- | ----------------------------------------- |
| üß† Purpose          | Run **custom logic** (code)           | Serve **static files** (HTML, JS, images) |
| üíª Runs Code?       | ‚úÖ Yes (JavaScript/TypeScript logic)   | ‚ùå No (only caches & delivers files)       |
| üèÉ Runtime          | V8 isolate (like serverless function) | Just a cache layer, no logic              |
| üì¶ Example Use Case | Auth, A/B test, dynamic rewrite       | Load CSS, images, and JS fast             |
| üåç Location         | Edge network (worldwide)              | Same ‚Äî edge network (worldwide)           |


A CDN is a warehouse that stores finished goods and delivers them fast.
An Edge Function is a smart mini-factory near the warehouse that can custom-make or modify the goods before delivery.

CDNs and Edge Functions often run on the same edge server ‚Äî the edge function runs custom logic first, then the CDN serves static content ‚Äî all close to the user for speed and flexibility.

next/link enables client-side navigation and preloading in Next.js, while a normal <a> tag triggers a full page reload ‚Äî losing all app state and performance benefits

Bonus: Prefetching Behavior
By default:

next/link preloads the page component when the link appears in the viewport or when hovered

Makes navigation feel instant

You can control it like:

<Link href="/about" prefetch={false}>About</Link>


Use _document.tsx to customize the static HTML structure (SSR only) and _app.tsx to add global layouts, providers, and logic to every page (CSR + SSR).


ctx stands for context, and it is an object passed into functions like:

getServerSideProps(ctx)
getInitialProps(ctx)
getStaticProps(ctx)
and Document.getInitialProps(ctx) (in _document.tsx)

ctx (context) is an object that contains everything Next.js knows about the current request ‚Äî like URL, query, cookies, params, etc. ‚Äî and is used in server-rendering and page setup functions.


export async function getServerSideProps(ctx) {
  const { req, res, params, query, resolvedUrl, locale } = ctx;
}

Property	Description
req	HTTP request object (like in Express)
res	HTTP response object
params	Route params like [id] from dynamic routes
query	Query string from URL (e.g. ?search=lehenga)
resolvedUrl	The full path requested
locale	Current locale (for i18n apps)


When would you use Context over Redux?

Use React Context for small, static global state (e.g., theme, auth status).
Use Redux for large, dynamic, deeply nested, shared state with complex updates or async logic.



 What problems does Redux solve?\

Centralized state management
Predictable state updates via reducers
Debuggable with time-travel tools
Scalable for large apps
Handles async actions via middleware


 What is Redux Toolkit and why is it preferred?

A modern wrapper over Redux that reduces boilerplate and adds best practices.

‚úÖ Benefits:

Simplified store setup
createSlice, createAsyncThunk
Built-in Immer for immutability
Devtools + middleware ready
Encourages best practices

Difference between useReducer and Redux?

Feature	        useReducer (React)	    Redux
Scope	          Local to one component	Global, app-wide
Middleware	      ‚ùå No	              ‚úÖ Yes (Thunk, Saga, etc.)
Devtools	        ‚ùå No	              ‚úÖ Yes
Async Support	    ‚ùå Manual	          ‚úÖ Built-in with middleware
Use Case	       Simple component state	Complex global state

How do you structure large-scale state in Redux?

Use Redux Toolkit
Split state into feature slices
Organize by feature: features/user/userSlice.ts
Use combineReducers() or configureStore()
Keep side effects in thunks or middleware

Explain middleware in Redux (e.g., Redux Thunk)

Middleware intercepts actions before they reach reducers ‚Äî used for logging, async calls, etc.
Thunk: lets you dispatch async logic (dispatch(fetchUser()))
Logger: logs actions/state for debugging
Custom: track analytics, auth, etc.

What is an action creator and reducer?

Action Creator: Function that returns an action

const addUser = (user) => ({ type: 'ADD_USER', payload: user });

Reducer: Pure function that updates state based on action type

function userReducer(state, action) {
  switch (action.type) {
    case 'ADD_USER': return [...state, action.payload];
  }
}


How do you persist Redux state across refresh?

Use redux-persist
It saves Redux state to localStorage or sessionStorage

import { persistStore, persistReducer } from 'redux-persist';


What are some alternatives to Redux?

| Alternative     | Use Case                      |
| --------------- | ----------------------------- |
| Zustand         | Lightweight, less boilerplate |
| Recoil          | Graph-like global state       |
| Jotai           | Primitive-based atomic state  |
| MobX            | Reactive observable state     |
| React Query/SWR | Async server-state caching    |


How does SWR / React Query help with caching?

They handle server state, not global app state.

Benefits:

Data fetching + caching out-of-the-box
Auto revalidation
Stale-while-revalidate strategy
Retry/focus/refetch on window focus
Great for APIs, pagination, mutations

React Query and SWR automatically cache and manage server-side data, making your UI fast, fresh, and resilient ‚Äî without needing Redux, loading states, or manual refetch logic.


How do you fetch data in React? Compare fetch and axios.

| Feature      | `fetch` (built-in)                     | `axios` (external lib)        |
| ------------ | -------------------------------------- | ----------------------------- |
| Syntax       | Verbose, manual parsing (`res.json()`) | Simple, returns JSON directly |
| Errors       | Doesn't throw on HTTP errors           | Throws on non-2xx responses   |
| Timeout      | Not built-in                           | Supports timeout              |
| Interceptors | ‚ùå No                                   | ‚úÖ Yes                         |
| File upload  | Manual `FormData` handling             | Easier with `axios.post()`    |


How do you cancel a request in Axios?

Use AbortController (Axios v1+) or CancelToken (v0.27):

const controller = new AbortController();
axios.get('/api/data', { signal: controller.signal });
controller.abort(); // cancels request

How can you debounce an API call?

Use setTimeout and clearTimeout:

useEffect(() => {
  const timer = setTimeout(() => {
    axios.get(`/api/search?q=${query}`);
  }, 500);

  return () => clearTimeout(timer);
}, [query]);

Or use lodash.debounce() or a custom debounce hook.

What is optimistic UI update?

Update the UI immediately as if the API call succeeded, then revert if it fails.

// optimistic update
setLikes(prev => prev + 1);

axios.post('/api/like').catch(() => {
  // rollback if failed
  setLikes(prev => prev - 1);
});

// optimistic update
setLikes(prev => prev + 1);

axios.post('/api/like').catch(() => {
  // rollback if failed
  setLikes(prev => prev - 1);
});


How do you cache API responses in the frontend?

| Method                | Description                          |
| --------------------- | ------------------------------------ |
| **React Query / SWR** | Built-in caching and background sync |
| **LocalStorage**      | Manual caching (e.g., on page load)  |
| **SessionStorage**    | Cache per tab/session                |
| **IndexedDB**         | Large offline data                   |


Storing a temporary copy of your data (pages, images, API responses)
so it can be delivered faster the next time it‚Äôs requested.

‚úÖ 1. What tools do you use to measure performance in React?

| Tool                        | Purpose                          |
| --------------------------- | -------------------------------- |
| **React DevTools Profiler** | Measures component render times  |
| **Chrome DevTools**         | Audit bundle size, layout, paint |
| **Lighthouse**              | Page performance + web vitals    |
| **Webpack Bundle Analyzer** | Visualizes JS bundle size        |
| **why-did-you-render**      | Logs unnecessary re-renders      |


Difference between Code Splitting and Tree Shaking

| Feature | Code Splitting                 | Tree Shaking                         |
| ------- | ------------------------------ | ------------------------------------ |
| Purpose | Split code into smaller chunks | Remove unused code from final bundle |
| When?   | At build or runtime            | During bundling                      |
| Example | `React.lazy`, dynamic import() | Unused functions/classes are removed |
| Tools   | Webpack, Vite                  | Terser, Webpack                      |


How can you reduce initial bundle size?

Use React.lazy() + Suspense
Split routes/components dynamically
Use tree-shakable libraries (e.g., lodash-es)
Avoid big libraries (moment.js ‚Üí date-fns)
Remove unused code and polyfills
Compress assets (gzip, Brotli)
Load fonts and styles async


What is React Profiler and how is it used?

A tab in React DevTools to analyze render performance.

‚úÖ It shows:

How long components took to render
What caused re-renders
Commit durations (slow components)

üì¶ Use <Profiler> in code for custom measurement:

<Profiler id="App" onRender={callbackFn}>
  <App />
</Profiler>


What are render-blocking resources?

Resources that delay the browser from rendering the page.

üü• Examples:

Synchronous JS <script> in <head>
Non-async CSS or fonts
Heavy blocking assets (images without lazy load)

‚úÖ Fix using:

defer or async on scripts
media or preload on styles/fonts
Lazy-load images and components

How would you optimize the re-renders in a React tree?

Use React.memo() to memoize components
Use useCallback and useMemo to avoid re-creating functions/values
Split large components
Avoid prop drilling (Context or Redux properly)
Minimize anonymous functions in JSX
Profile with React DevTools to find heavy renders

How do you defer offscreen content loading?

| Technique                          | Description                     |
| ---------------------------------- | ------------------------------- |
| `loading="lazy"`                   | On `<img>` and `<iframe>` tags  |
| `IntersectionObserver`             | Detect when elements enter view |
| `React.lazy` + Suspense            | Defer loading heavy components  |
| Virtualization (e.g. react-window) | Load only visible list items    |

 Prevents loading things user can‚Äôt see yet = faster page load.


‚úÖ 1. What is the role of Webpack/Babel in a frontend app?

| Tool        | Purpose                                                      |
| ----------- | ------------------------------------------------------------ |
| **Webpack** | Bundles JS, CSS, images into optimized static assets         |
| **Babel**   | Transpiles modern JS/JSX into backward-compatible code (ES5) |


‚úÖ 2. What is the purpose of a .babelrc file?

Config file to define Babel presets and plugins.

{
  "presets": ["@babel/preset-env", "@babel/preset-react"]
}


‚úÖ 3. Explain how transpiling works in modern apps.

Converts modern JavaScript (ES6+) into older versions that browsers understand (ES5).
Babel reads code ‚Üí applies plugins ‚Üí outputs browser-safe code.


‚úÖ 4. What is a monorepo? Tools used to manage it?
A single repo that contains multiple projects/packages.

‚úÖ Tools:

Turborepo
Nx
Lerna
Yarn Workspaces

‚úÖ 5. What is tree shaking?

Removes unused imports from final JavaScript bundles.

‚úÖ Done during bundling (e.g., by Webpack + Terser) to reduce bundle size.


‚úÖ 6. Explain CORS and how to handle it.

Cross-Origin Resource Sharing: A security rule in browsers that blocks API calls to different origins unless explicitly allowed.

‚úÖ Fix: On server, add headers like:

Access-Control-Allow-Origin: *

Or restrict to your domain.


‚úÖ 7. What is a Service Worker? How is it used?

A background JS file that intercepts network requests, caches assets, and enables offline capabilities.

Used in:

PWAs
Background sync
Push notifications

‚úÖ 8. Explain PWA and its advantages.
Progressive Web App = Web app that feels like a native mobile app.

‚úÖ Benefits:

Offline support (via service worker)
Add to Home Screen
Push notifications
Fast load times (caching)
No app store needed

‚úÖ 10. Accessibility: what are ARIA roles?
ARIA (Accessible Rich Internet Applications) roles help screen readers interpret UI components.

Examples:

role="button" for custom div buttons
role="dialog" for modals
aria-label, aria-expanded for extra context

‚úÖ 11. SEO best practices in Next.js?

Use next/head for meta tags
Use getStaticProps or getServerSideProps for SEO content
Generate sitemap and robots.txt
Use semantic HTML (<main>, <article>, etc.)
Implement structured data (schema.org JSON-LD)
Optimize images (next/image)


‚úÖ 12. Difference between hydration and rehydration?

| Term            | Meaning                                                                                             |
| --------------- | --------------------------------------------------------------------------------------------------- |
| **Hydration**   | React attaching event listeners to server-rendered HTML (on first page load)                        |
| **Rehydration** | (Less common term) Sometimes used interchangeably, or to describe reattaching state after cache/SSR |


What is a Service Worker?

A Service Worker is a special type of JavaScript file that runs in the background of your browser, separate from the main webpage.
It does not have access to the DOM directly, but it can:

Intercept network requests
Cache files for offline use
Push background notifications
Improve load speed (by serving from cache)

It acts like a proxy between your app and the network.



| Feature          | **Next.js Middleware**                       | **NestJS Middleware**                  | **NestJS Interceptor**                                    |
| ---------------- | -------------------------------------------- | -------------------------------------- | --------------------------------------------------------- |
| **When it runs** | Before a request hits a route (edge level)   | Before request reaches controller      | Before & after controller or route handler                |
| **Access to**    | Request/response headers, URL                | `req`, `res`, and `next()`             | `ExecutionContext`, `callHandler` (Observable)            |
| **Used for**     | Routing, auth, rewriting, geolocation        | Logging, auth, parsing headers         | Transform response, logging, exception wrapping           |
| **Async-aware**  | Yes                                          | Yes                                    | Fully RxJS-based (can handle async and streams)           |
| **Location**     | `middleware.ts` or inside `/middleware` dir  | `app.module.ts` or controller-specific | Implemented with `@Injectable()` and `@UseInterceptors()` |
| **Modifies**     | Often modifies request/response or redirects | Can modify request before controller   | Can modify request and **response**                       |



Async-aware means that the function, component, or middleware can handle asynchronous operations properly, like:

async/await functions
Promises
Streams (Observables in NestJS)
Delayed or non-blocking execution

Async-aware code doesn't break or finish early when dealing with delays, network calls, or timeouts. It waits 
for the async task to finish (or handles it correctly)

| Term            | Meaning                                     | Why It Matters                                          |
| --------------- | ------------------------------------------- | ------------------------------------------------------- |
| Async-aware     | Code that properly waits or handles `await` | Prevents bugs, race conditions, and premature execution |
| Non-async-aware | Ignores async timing; continues immediately | Can cause unhandled promises or early exits             |






















Sure Devdatt ‚Äî here's a **concise yet professional answer** to each question. You can memorize or personalize these depending on the interview style.

---

### ‚úÖ **21. What advantages did SSR bring to Zorahi's user experience?**

SSR improved initial load time, SEO for product pages, and ensured dynamic pages were crawled correctly by search engines, leading to better discoverability and user retention.

---

### ‚úÖ **22. How did you implement SSR for dynamic product pages?**

Used `getServerSideProps` in Next.js to fetch product data at runtime based on slug. This ensured real-time data and SEO-friendly rendering for each product detail page.

---

### ‚úÖ **23. What was your approach to making Zorahi mobile-first?**

Designed using mobile-first breakpoints in Tailwind CSS. Prioritized thumb-friendly UI, vertical stacking, and performance optimizations for 3G/4G networks.

---

### ‚úÖ **24. How did you handle responsive layouts across a wide range of devices?**

Used Tailwind‚Äôs responsive utilities (`sm`, `md`, `lg`) to build fluid layouts. Also tested across various viewports and used Chrome DevTools for emulation.

---

### ‚úÖ **25. How did you implement dynamic routing in Next.js?**

Used file-based routing with dynamic parameters like `[slug].tsx` for products. Leveraged `getStaticPaths` + `getStaticProps` where possible for performance.

---

### ‚úÖ **26. What is the difference between SSR and SSG in your use case?**

SSR for user-specific or time-sensitive data (e.g., orders); SSG for stable public content like product listings where performance mattered most.

---

### ‚úÖ **27. How did you optimize Zorahi‚Äôs frontend bundle size?**

Code-splitting via dynamic imports, lazy loading non-critical components, removing unused dependencies, and analyzing bundles using `next build --analyze`.

---

### ‚úÖ **28. What accessibility standards did you follow?**

Used semantic HTML, ensured keyboard navigation, proper color contrast, alt text for images, and basic ARIA roles for key components.

---

### ‚úÖ **29. How did you manage shared layout components across pages?**

Wrapped common layouts (e.g., navbar, footer) inside `_app.tsx` and structured pages using a layout pattern with conditional rendering based on routes or roles.

---

### ‚úÖ **30. Did you use `_app.tsx` or `_document.tsx` customization? Why?**

Yes. `_app.tsx` for global styles and context providers (like Auth, RBAC); `_document.tsx` for injecting meta tags and fonts during SSR for performance.

---

### ‚úÖ **31. What tools did you use to measure frontend performance?**

Used Chrome Lighthouse, Web Vitals plugin, and Next.js‚Äô built-in metrics. Also tracked Core Web Vitals like LCP, FID, CLS actively during dev.

---

### ‚úÖ **32. How did you manage metadata and dynamic tags for SEO?**

Used `next/head` to inject dynamic meta titles, descriptions, and OG tags based on product/page content from the backend.

---

### ‚úÖ **33. What libraries did you use for date pickers, modals, or other UI components?**

Used Ant Design for dashboards, React-DatePicker for booking calendar, and Headless UI for modals and transitions where customization was needed.

---

### ‚úÖ **34. What were the biggest challenges in building vendor dashboards?**

Balancing feature depth with simplicity for boutique owners, managing role-based component rendering, and handling edge cases in orders/returns logic.

---

### ‚úÖ **35. How did you handle media uploads (e.g., product photos)?**

Frontend: File input with preview and validation ‚Üí API route ‚Üí uploaded to Cloudinary using secure signed URLs for direct client upload.

---

### ‚úÖ **36. How did you prevent layout shifts or CLS issues?**

Reserved image container heights, avoided injecting content without space, and preloaded critical fonts and scripts to avoid shift during hydration.

---

### ‚úÖ **37. Explain your CSS strategy‚ÄîTailwind, MUI, or custom?**

Tailwind for rapid styling and consistency; MUI selectively for dashboard components. Combined utility-first CSS with reusable components.

---

### ‚úÖ **38. How did you handle forms, validations, and errors on the frontend?**

Used React Hook Form with Yup for schema-based validation, showed inline errors, and handled async API error feedback elegantly.

---

### ‚úÖ **39. Did you use lazy loading or infinite scroll anywhere? Why?**

Yes. Used lazy loading for images and modals to improve initial load. Used paginated load (not infinite scroll) for better SEO and user control on listings.

---

Let me know if you want these grouped into flashcards or formatted into a Notion-ready interview doc. I can also expand any one if they ask for a deeper follow-up.


Absolutely, Devdatt. Here's a **concise, recruiter-ready answer** to each of your 20 backend architecture questions from Zorahi, keeping it technically sound but brief:

---

### ‚öôÔ∏è **NestJS, Microservices & Docker**

1. **Why did you choose NestJS for your backend?**
   ‚Üí NestJS offered a structured, scalable, and TypeScript-first framework ideal for building modular, testable microservices.

2. **How did you structure your microservices?**
   ‚Üí Each service was isolated by domain: `auth-service`, `order-service`, `vendor-service`, `product-service`, with a shared contracts layer and gateway.

3. **What criteria did you use to split logic into services?**
   ‚Üí Based on business boundaries and database ownership to reduce coupling and ensure independent scalability.

4. **How did the services communicate with each other?**
   ‚Üí Used REST for simple communication and message queues (like RabbitMQ or Redis pub/sub) for decoupled async workflows.

5. **How did you use Docker in the local and production setup?**
   ‚Üí Each service had its own Dockerfile, managed via `docker-compose` locally; in production, we deployed containers via orchestrated scripts.

---

### üß≠ **Routing, DB Strategy, Uploads**

6. **How did you manage service discovery or internal routing?**
   ‚Üí Used internal DNS from Docker Compose for local resolution; considered service registry for production with reverse proxy (e.g., NGINX).

7. **Why use PostgreSQL and MongoDB both? What data goes where?**
   ‚Üí PostgreSQL handled structured data (users, orders), while MongoDB was used for flexible, nested product metadata and logs.

8. **How did you structure the PostgreSQL schema for orders and users?**
   ‚Üí Normalized relational schema with foreign keys between users, products, and orders. Used enums and timestamps for status tracking.

9. **How did you handle file/image uploads?**
   ‚Üí Used signed URLs from Cloudinary. Frontend directly uploaded via secure client tokens, backend only handled URL persistence.

10. **What kind of indexing strategies did you use in MongoDB?**
    ‚Üí Compound indexes on fields like `category + location`, full-text index on product titles and descriptions for search optimization.

---

### üîê **Security, Auth, APIs**

11. **How did you ensure transactional integrity in PostgreSQL?**
    ‚Üí Wrapped multi-step operations in SQL transactions using Prisma's `$transaction()` API to prevent partial writes.

12. **How did you implement authorization in NestJS?**
    ‚Üí Used role-based guards and decorators (`@Roles()`) with metadata checks, applying access control at route and service levels.

13. **How did you handle authentication ‚Äî sessions, JWT, or something else?**
    ‚Üí JWT-based stateless auth for APIs, with refresh token rotation stored securely (e.g., HTTP-only cookies or DB-backed store).

14. **How did you ensure APIs are secure and rate-limited?**
    ‚Üí Implemented rate-limiting middleware via NestJS interceptors, CORS policy enforcement, and schema validation on input.

15. **Did you use Swagger or Postman for API docs/testing?**
    ‚Üí Swagger with `@nestjs/swagger` for live docs, versioned APIs; Postman was used for manual testing by non-devs and partners.

---

### üöÄ **DevOps, Logs, Scaling**

16. **How did you configure and deploy Docker containers?**
    ‚Üí Used multi-stage Dockerfiles for optimized builds, environment-based `.env` files, and shell scripts for versioned deployment.

17. **What CI/CD system did you use to push updates to production?**
    ‚Üí GitHub Actions for CI, connected to a private VPS or container host for auto-pull and rebuild on `main` push with pre-deploy checks.

18. **How did you monitor logs and errors across services?**
    ‚Üí Used Winston with a centralized log transport (e.g., file + HTTP push), plus custom error hooks to send alerts to Slack/email.

19. **How did you handle multi-tenant scenarios or isolation for different vendors?**
    ‚Üí Scoped data by vendor ID at query level; guarded every access path to ensure vendors only see their own resources.

20. **How would you redesign the architecture for 10x traffic?**
    ‚Üí Add API gateway with rate-limiting, shift to managed DBs, use Redis caching, autoscaling containers, and async job queues for non-critical flows.

---

Let me know if you want a **PDF**, **Notion board**, or to dive deeper into any one of these with diagrams or code snippets.



Here are concise and professional answers to the 15 questions related to **RBAC, orders, delivery, and vendor flows** in Zorahi:

---

### üõ°Ô∏è **RBAC & Access Control**

1. **How is RBAC implemented technically in Zorahi?**
   ‚Üí Roles are embedded in JWTs and checked using NestJS guards and decorators (`@Roles()`). Access is enforced both at route and service levels.

2. **How many roles exist in the system? What are their permissions?**
   ‚Üí Five roles: Admin (full access), Vendor (manage products/orders), Customer (browse/rent), Delivery Agent (track deliveries), Store Manager (process handovers).

3. **How did you ensure role-based UI changes in the frontend?**
   ‚Üí Role from JWT is decoded and stored in client context. Conditional rendering is applied at both route and component levels.

4. **How do you prevent privilege escalation?**
   ‚Üí Permissions are strictly enforced server-side. Role-based guards reject unauthorized actions even if frontend is manipulated.

5. **Can a vendor access another vendor‚Äôs data? Why not?**
   ‚Üí No. All data queries are filtered using `vendorId` scoped to the logged-in user. Direct access is rejected with 403.

---

### üì¶ **Order Flow & Fulfillment**

6. **Describe the complete flow from a customer placing an order to delivery.**
   ‚Üí Customer selects product ‚Üí places order ‚Üí vendor approves ‚Üí store manager processes ‚Üí delivery agent picks up ‚Üí status tracked until delivered.

7. **How do you track order status across different services?**
   ‚Üí Each service updates order status via a centralized `order-service`. Status is published to a message queue and consumed by relevant services.

8. **What happens when an order is canceled midway? Is it atomic?**
   ‚Üí Yes. A transaction updates order state and triggers reversal flows like product availability reset and refund initiation.

9. **How does the store manager interface differ from the vendor?**
   ‚Üí Store managers only see assigned pickups/returns and process physical exchanges. Vendors see product listings, analytics, and full order lifecycles.

10. **How did you implement live updates on order or status?**
    ‚Üí Used polling + socket.io for real-time order status updates on dashboards for vendors and store managers.

---

### üöö **Delivery & Logistics**

11. **How do delivery agents get assigned?**
    ‚Üí Auto-assignment is based on availability and proximity (if known), else fallback to manual assignment by store manager or admin.

12. **How did you notify users (emails, SMS, or in-app)?**
    ‚Üí Used Nodemailer for emails, third-party SMS service (Twilio-like), and toast/in-app notifications via WebSocket and local storage.

13. **How do you prevent duplicate bookings of a product?**
    ‚Üí On order creation, we check overlapping rental dates and lock the product's availability during the selected window.

---

### üè™ **Vendors & Onboarding**

14. **What‚Äôs the vendor onboarding flow from signup to going live?**
    ‚Üí Vendor signs up ‚Üí completes KYC/upload verification docs ‚Üí admin approves ‚Üí vendor dashboard activated ‚Üí products added ‚Üí shop goes live.

15. **How did you train boutiques with minimal tech knowledge?**
    ‚Üí Created simple, icon-based dashboards, video tutorials in regional languages, and provided call support during early onboarding.

---

Let me know if you want follow-up responses or diagrams for any of these.



Certainly Devdatt ‚Äî here are **precise, interview-ready answers** for your SEO and performance questions:

---

### ‚úÖ **SEO & SSR in Zorahi**

1. **How did you ensure products were crawlable by Google?**
   ‚Üí Used Next.js SSR for product pages via `getServerSideProps`, ensured clean URLs, avoided client-side only rendering.

2. **What dynamic SEO tactics did you implement?**
   ‚Üí Dynamically injected meta tags, OG tags, and schema (JSON-LD) using product data fetched at runtime to optimize discoverability.

3. **How did you use `next/head` for meta tags and OG tags?**
   ‚Üí Inside each product page, used `next/head` to render dynamic `<title>`, `<meta name="description">`, `og:image`, etc., based on product details.

4. **How did you handle canonical URLs?**
   ‚Üí Added `<link rel="canonical">` dynamically inside `next/head`, pointing to the primary URL of the product to avoid duplicate indexing.

5. **What challenges did you face in pre-rendering dynamic pages?**
   ‚Üí For frequently updated or newly added products, managing fallback rendering in `getStaticPaths` was tricky; SSR was chosen for real-time content.

---

### ‚úÖ **Performance Optimization**

6. **What‚Äôs the difference between `getStaticPaths` and `getServerSideProps`?**
   ‚Üí `getStaticPaths` is for pre-rendering paths at build time (SSG), while `getServerSideProps` fetches fresh data at each request (SSR).

7. **How did you minimize TTFB and LCP?**
   ‚Üí Reduced API latency, used image optimization (`next/image`), server caching, compressed assets, and minimized render-blocking resources.

8. **Did you implement structured data (JSON-LD) for products?**
   ‚Üí Yes, used JSON-LD `<script>` inside `next/head` for product schema (`@type: Product`) to enhance Google Rich Results.

9. **How did you integrate analytics or events tracking?**
   ‚Üí Integrated Google Analytics and custom event tracking via `gtag.js`, including product views, add-to-cart, and order conversions.

10. **What was your Core Web Vitals score and how did you improve it?**
    ‚Üí Targeted >90 scores. Optimized LCP via lazy image loading, CLS by reserving image space, and FID using minimal third-party JS.

---

Let me know if you‚Äôd like to turn these into flashcards or if you'd like a diagram-based explanation for SEO and Web Vitals.



Absolutely, Devdatt. Here are **precise and concise** answers to each of those questions ‚Äî clear enough for interviews, but brief enough to avoid rambling.

---

### ‚öôÔ∏è **Engineering Leadership & Decision Making (Concise Answers)**

1. **What tech decisions did you take that saved the most dev time?**
   ‚Üí Used NestJS + Prisma for structured backend, and Tailwind CSS + component libraries to speed up frontend UI with consistency.

2. **What would you do differently if building Zorahi today?**
   ‚Üí Adopt serverless for faster scaling, use PostgreSQL-only to reduce DB complexity, and add analytics from day one.

3. **How did you manage feature planning and sprint cycles?**
   ‚Üí Prioritized based on user needs and business impact. Used Trello with weekly sprints and daily personal standups to stay accountable.

4. **How do you ensure test coverage and reliability?**
   ‚Üí Wrote critical-path unit tests, tested major user flows manually, and used post-deploy checks with fallback guards.

5. **Did you write unit or integration tests for your services?**
   ‚Üí Yes, unit tests for business logic in NestJS and integration tests for key APIs like order, auth, and vendor flow.

6. **How did you manage dependencies and tech debt?**
   ‚Üí Used RenovateBot for updates, documented known tech debt, and scheduled monthly refactoring windows post-feature release.

7. **How did you decide where to use MongoDB vs SQL?**
   ‚Üí PostgreSQL for relational data (users, orders); MongoDB for flexible, schema-less content like product variants and logs.

8. **What did you prioritize when traffic started to grow?**
   ‚Üí Optimized DB queries, added Redis caching, moved heavy tasks to queues, and lazy-loaded non-critical frontend content.

9. **How did you make sure new features didn‚Äôt break old ones?**
   ‚Üí Followed modular design, tested key flows after each release, used feature flags, and documented breaking changes.

10. **How did you collaborate with boutique owners or delivery agents?**
    ‚Üí Built simple, icon-based dashboards; took direct feedback through video calls and WhatsApp to iterate quickly.

11. **How would you hire your first frontend developer at Zorahi?**
    ‚Üí Look for strong fundamentals, ownership mindset, and experience with Next.js + Tailwind. Start with contract trial + mentorship.

12. **How did you make technical decisions with limited data or uncertainty?**
    ‚Üí Focused on shipping fast, used MVP-first approach, validated with users, and kept architecture flexible for pivots.

13. **How did you debug live issues under pressure?**
    ‚Üí Checked logs, isolated the service, used Postman to test APIs, rolled back if needed, and added monitoring to avoid recurrence.

14. **How did you keep security in mind while scaling features?**
    ‚Üí Used HTTPS, input validation, RBAC, token expiry, rate-limiting, and secured sensitive operations via backend-only logic.

15. **What does being a "Founding Engineer" mean to you ‚Äî and how do you show it?**
    ‚Üí It means owning the product end-to-end, making trade-offs for the business, staying hands-on, and solving problems beyond the code.

---

Let me know if you want to refine any of these for a **storytelling format (STAR)** or if you'd like a mock interview round from this section.


