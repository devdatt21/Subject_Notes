
how to create a react project :     

    npx create-react-app myReactApp
    cd myReactApp
    npp start 


contains of myReactApp : 
    node_modules : libraries
    package.json : dependencies with versions and scripts 
    public folder : index.html
    src folder : components and index.js    


javascript XML(JSX)
    syntax extension that allows you to write HTML 
    directly within JS 

    ex. 

        const name = "josh perez";
        const element = <h1> hello, {name} </h1>

        ---------------------------------

        function formatName(user){
            return user.firstName + ' ' + user.lastName ;
        }

        const user = {
            firstName : "devdatt",
            lastName : "rupapara",
        }

        const element = (
            <h1>
                hello, {formateName(user)};
            </h1>
        )


React ex. 

    html file 

        div id="root"

        /div 

    js file 
    
        const root = ReactDOM.creatRoot(document.getElementById('root'));
        root.render(<h1>Hello, world</h1>);

    output 

        Hello, world 
    

React element 

    react element, is a lightweight description of what 
    to render, in javascript XML(JSX).

    elements are smallest building blocks of the react app 

    react elements can represent : DOM tags or user-defined 
        components 

    react elements are plain JS objects and are cheap 
        to create 
    
    react DOM takes care of updating rendered screen to 
        match the react elements 
    
        > reactDOM is a library in react used to interect   
        with the DOM in web application 


Rendering react elements 

    to render a react element 
        pass the DOM element to ReactDOM.createRoot(),
        then pass the react element to root.render()

    updating rendered react elements 
        react only updates what is necessary 
            react compares the elements and it's children
            to previous ones and only make necessary 
            changes to bring the DOM in a desired state 
    
Defining Components 

    components let you split the UI into independent,
    reusable pieces and think about each piece in isolation 

    conceptually, components are like javascript functions 
        input : props
        return react elements 
    
    2 ways to define 
        (always start a component name with a capital letter)
        function 
        class 
    
    <div /> is an html tag and <Welcome /> is a class 
    component and requires Welcome to be in scope 

creating and using compo.

    inside src folder, create a comonent folder 
    app.js is the main component 

    exporting and importing as per (ES6 module)
        export default Greeting;
        import Greeting from './Greeting'
    
    each React component is eancapsulated and can 
    operate independently; this allows you to build 
    complex UIs from simple comps. 

    comps can be nested and can be called multiple times 

Event handling on DOM vs. React elements 

    similar but there are syntex differences 
        react events are named using camelCase, rather 
            than lowercase 
        with JSX u pass a func as event handler, rather 
            than a string 
    
        preventing a default behavior 
            html 
                onsubmit="console.log('clicked'); return false;"
            
            react 
                e.preventDefault();
        
React Router 

    for routing in react

    enables navigation of ur app by handling URL paths 
    and rendering components dynamically

    3 main comps :
        1. <Nav> 
              <Link to="/"> Home </Link>
            ex. 
            
            nav is used to navigate user by clicking on link 
                on page 
                 <Nav>
                    <Link to="/">Home</Link>
                    <Link to="/about">About</Link>
                </Nav>
            
            route is used to render a comp when user gose to 
                particuler route 
                <Routes>
                    <Route path="/" element={<Home />} />
                    <Route path="/about" element={<About />} />
                </Routes>
                
        2. <Routes>

           3. <Route path="/about" component={About} />
        
        </Routes>

        <Route path="/" element={<Home />} />


Inline if with logical && operator 
    
    unreadMessage.length > 0 && 
        <h2> you have {unreadMessage.length} unread messages
        </h2>

Inline If-else 

    unreadMessage.length > 0 ? 
        <h2> you have {unreadMessage.length} unread messages
        </h2>
        :
        <h2> no messages
        </h2>


Rendering Lists 

    display array of items (users, products)
    dynamically generating comps based on data 
    handling dynamic changes (adding/removing)

    to render list in React

        JS's .map() method is used to iterate over
            array
        return JSX for each item 
        each item in a list must have a unique key prop
            to help react efficienlty update the DOM 
            when the list changes. the key helps react 
            identify which items have changed, been 
            added or removed

        code : 

        <ul>
            {items.map(item => (
                <li key={item}> {item} </li>
            ))}
        </ul>

React Hooks 

    react hooks are funcitions that let us hook into 
    the react state and lifecycle methods from 
    function components 
    
    ex. 
        useState() : returns an array with a stateful 
            value and a function to update it 

            allow you to add state to functional components

            useState returns an array with 2 elements 
                state and updater function 
            
            can be used multiple times in the same component 
            
            code : 

                const [state, setState] = useState(initialValue);

                onClick={() => {
                    setCount(count + 1);
                }}

        useEffect() : perform side effects in function
            components 

            to : 
                fetch data 
                manage timers
                manually changing the DOM 

            ex. useEffect(() => {
                fetchData();
            },[]);

            dependencies : listed as array and second argument 
                you can have multiple useEffect hooks to 
                saparate concerns 

                [count]

3 phases of comp lifecycle 

    mounting 
        when comp is inserted into the DOM 

        1. constructor() : 
            called before anything else
            natural place to setup the initial state 
                and other initial value 
            you should always start by calling super(props)
                before anything else.

        2. getDerivedStateFromProps()
            called right before rendering the elements in 
                the DOM 
            
        3. render() :   
            method that actually outputs the HTML to the DOM 

        4. componentDidMount()
            called after the components is rendered 
            where u can run statements that requires that 
                the component is already placed in the dom

    
    updating 
        comp re-renders due to change in prop or state 

        1. getDerivedStateFromProps()
            first method to call when comp gets updated 
            natural place to set state object based on 
                initial props 
            
        2. shouldComponentUpdate() 
            method you can return a boolean value that 
                specifies whether React should continue 
                the the rendering or not 
            

        3. render()
            called when component gets updates 

        4. getSnapshotBeforeUpdate()
            in this method u have access to props and state 
                before the update 
            u can check what values were before the update 

        5. componentDidUpdate()
            called after the comp is updated in DOM 

    
    unmounting 
        when the component is removed from the DOM 

        1. componentWillUnmount()
            called when the comp is about to be removed 
                from the DOM 

    

frontend using plain JS and react 

    feature            plain JS                                 react 


    handling state     DOM manipulation with getElementById     managed with useState hooks 

    event handling     addEventListener on the form elem.       inline onSubmit handler in JSX. 

    rendering          Direct DOM updates                       dynamic rendering via react JSX.

    componentization   static HTML and JS                       reusable react component    

    dynamic updates    manual DOM updates                       React re-renders when state changes 

   


Virtual Dom :   
    desigend to optimize performance by minimizing 
direct interactions with the real DOM 
    each element in the DOM is a node in this tree 

    working :

        react creates a virtual represantation of the UI as a 
        tree of JS objects 

        it generates a new virtual DOM tree to reflect updates 
        state when the application state changes 

        react compares the new virtual DOM tree with the previous 
        one using it efficient diffing algorithm to identify the 
        minimal set of changes required 

        react applies only the neccessary changes to the 
        real DOM, optimizing rendering performance.

    



Error Boundary :

    a Class comp becomes an error boundart if it defines 
    either (or both) of the lifecycle methods 
    static getDerivedStateFromError() 
    or componentDidCatch()

    use static getDerivedStateFromError() to render a fallback
    UI after an error has been thrown.

    use componentDidCatch() to log error information 

    code : 
    
    class ErrorBoundary extends React.Component {
        constructor(props) {
            super(props);
            this.state = { hasError: false };
        }

        static getDerivedStateFromError(error) {
            // Update state so the next render will show the fallback UI.
            return { hasError: true };
        }

        componentDidCatch(error, errorInfo) {
            // You can also log the error to an error reporting service
            logErrorToMyService(error, errorInfo);
        }

        render() {
            if (this.state.hasError) {
            // You can render any custom fallback UI
            return <h1>Something went wrong.</h1>;
            }

            return this.props.children; 
        }
    }

    then u can use it as a regular comp 
    
    <ErrorBoundary>
        <MyWidget />
    </ErrorBoundary>


    error boundaries work like a JS catch{} block,
    but for components. only class components can be error 
    boundaries.

    in practices, most of the time you'll want to declare 
    an error boundary comp once and use it throughout 
    your application

    note that error boundaries only catch errors in the 
    comps below them in the tree 

    an error boundary can't catch an error within itself
    
    if an error coundary fails trying to render the error 
    message, the error will propogate to the closest error
    boundary above it.

    this, too, is similar to how the catch {} block works 
    in JS.


props and state : 

    props : ways to pass properties/data from parent component
    to child component while the 

        the data is passed from 1 comp to another 

        it is immutable (cannot be modified)

        props can be used with state and functional comp 

        props are read-only

    state : is the real-time data available to use within only 
    that component.

        data is passed within comp 

        it is mutable 

        the state can be used only with the state comp/class 
        comp 




All Basic hooks : 

JSX : 

    javascript XML 
    used to describe UI 
    allows to write html like code directly within JS 
    under the hood, HSX gets trasplied into reguler JS using 
        tool like babel 
    if you dont want to use JSX then you have to use 
        React.createElement('div',{id:'hello',className:'dummClass'},React.createElement('h1',null,'hello vishwas'));
        

        Babel : (traslator)

            you wrote something in the latest fancy version 
            of JS, but not all browsers or systems understand 
            it yet.

            babel takes your code and converts it into a simpler 
            version that all browsers and environments can understand
            it makes your code work everywhere, even on older browser

            JS compiler and toolchain mainly used to convert modern
            JS into older versions so that it can run in environments
            or browsers that dont support the latest features                   




Life cycles in react

Optimization techniques (useMemo, useCallback) : 
    The useCallback and useMemo Hooks are similar. The main difference is that 
    useMemo returns a memoized value and useCallback returns a memoized function.
    
    useMemo() : 
        used to memoize a computed value so that is only recalculated 
        when its dependencies change.

        it avoids recalculating expensive operations unnecessarily

        code :  
            const memoizedValue = useMemo(()=> computeValue, [dependencies])

                computeValue : a function that returns the value to be memoizedValue
                dependencies : an array of values that when changed, will re-trigger the computation

    useCallback() : 
        const addTodo = useCallback(() => {
            setTodos((t) => [...t, "New Todo"]);
        }, [todos]);

        Comparison: useMemo vs useCallback
        Feature	    useMemo	                        useCallback
        Purpose	    Memoize a value	                Memoize a function
        Return      Value	Returns the memoized    result	Returns the memoized function
        Common      Use Case	Avoid recalculating	Avoid re-creating functions unnecessarily
                        expensive operations
Pure Component : 

    in react is like a super-efficient worker who does a task only 
    if absolutely necessary. 

    it checks if the input (data or props) has changed before doing 
    it's work (re-rendering). 

    if the input hasn't changed, it just skips the task to save time 
    and resources.

    it automatically prevents unnecessary re-renders 
    it performs shallow comparison of its props and state 
    if the values havent changed, react skips re-rendering 
        the component 

        2 types : 

            class-based : 
                React.PureComponent
            
            functional : 
                React.memo() (optimised)

    normal comp will re-render every time it's parent 
    comp re-renders 

    but 

    pure comp performs a shallow comparison of the current props/state 
    with the previous ones before re-rendering.

    use : 
        when your comp renders the same output for the same set 
        of props and state 



state management (Redux, context and difference) :  
    
    context API : 
        to avoid prop drilling (passing props through many layers of components)
        allows to share state btw components at 
        different nesting levels 

    code : 
            import React, {useContext, useState, createContext, Children} from "react";

            // creating context 

            const MyContext = createContext();

            //provider function (we will wrap this function around the chlid function to access all the need data)

            const MyProvider = ({children}) => {
                const [name, setName] = useState("Devdatt")
                
                return (
                    <MyContext.Provider value={{name, setName}}>
                        {children}
                    </MyContext.Provider>
                )
            }

            const ChildComponent = () => {
                const {name, setName} = useContext(MyContext);

                return(
                    <div className="flex flex-col items-center ">
                        <h1>{name} </h1>
                        <button className="bg-black text-white font-bold m-2 p-2 rounded-sm" onClick={() => setName("John wick")}> Change Name </button>
                    </div>
                )
            }

            const ContextComp = () => {


                return (
                    <MyProvider>
                        <ChildComponent/>
                    </MyProvider>
                )
            }

            export default ContextComp;



render props : 
    technique for sharing code btw react comps using a 
    props whose value is a function 

    a comp with a render prop takes a func that 
    returns a react element and calls it instead of
    implementing its own render logic.

     code : 
        
        import React, { useState, useEffect } from "react";

        function Clock({ render }) {
            const [time, setTime] = useState(new Date());

            useEffect(() => {
                const timer = setInterval(() => {
                    setTime(new Date());
                }, 1000);

                return () => {
                    clearInterval(timer);
                };

            }, []);

            return render(time);
        }

        function App() {
            return (
                <div className="App">
                <h1>Render Props Example</h1>
                <Clock
                    render={(time) => {
                        return <p>The current time is {time.toLocaleTimeString("en-US")}</p>;
                    }}
                />
                </div>
            );
        }
   

Routing : 

    code : 

        import React from "react";
        import { BrowserRouter as Router, Routes, Route, Link } from "react-router-dom";
        import Home from "./Home";
        import About from "./About";
        import Contact from "./Contact";

        function App() {
        return (
            <Router>
            <nav>
                <Link to="/">Home</Link> | <Link to="/about">About</Link> | <Link to="/contact">Contact</Link>
            </nav>
            <Routes>
                <Route path="/" element={<Home />} />
                <Route path="/about" element={<About />} />
                <Route path="/contact" element={<Contact />} />
            </Routes>
            </Router>
        );
        }

        export default App;




        import React from "react";
        import { BrowserRouter as Router, Routes, Route, Link, useParams } from "react-router-dom";

        function App() {
        return (
            <Router>
            <nav>
                <Link to="/">Home</Link> | <Link to="/user/1">User 1</Link> | <Link to="/user/2">User 2</Link>
            </nav>
            <Routes>
                <Route path="/" element={<Home />} />
                <Route path="/user/:id" element={<User />} />
            </Routes>
            </Router>
        );
        }

        function Home() {
            return <h2>Welcome to the Home Page!</h2>;
        }

        function User() {
            const { id } = useParams(); // Extract the dynamic "id" parameter from the URL.
            return <h2>User Page: User ID is {id}</h2>;
        }

        export default App;





        import { useNavigate } from "react-router-dom";

        function Home() {
            const navigate = useNavigate();
            return <button onClick={() => navigate("/about")}>Go to About</button>;
        }


Forms and Inputs:
    Controlled vs. uncontrolled components.
        controlled comp is a form element whose value is fully 
        controlled by react state

        the input element's value is bound to a state variable 
        react takes full control over the component's state 
        updates to input happen via onChange handlers 
    
    uncontrolled comp : 
        an uncontrolled comp is a form element where the value 
        is not controlled by react's state. 
        
        input's value is managed by the DOM itself. 
        react only interacts with the DOM to access the value 
        when needed. 

        react doesn't manage the value; it relies on the 
        native DOM to handle input data 
        
        you use a ref to access the value of the input 
        element

        code :  
            import React, { useRef } from 'react';

            function UncontrolledForm() {
            const inputRef = useRef(null);

            const handleSubmit = (e) => {
                e.preventDefault();
                console.log('Submitted Value:', inputRef.current.value);
            };

            return (
                <form onSubmit={handleSubmit}>
                <label>
                    Name:
                    <input type="text" ref={inputRef} />
                </label>
                <button type="submit">Submit</button>
                </form>
            );
        }

        export default UncontrolledForm;





    Form handling with onChange and onSubmit.

        the onChange event is triggered whenever the value 
        of an input field changes. 

        it is commonly used to update the component's state 
        with latest value entered by the User

        the onSubmit event is triggered when the form is submitted
        button of type submit is clicked 

        it is commonly used to process the form data or send it 
        to a server 

Styling in React:
    CSS Modules.
        CSS modules allow you to write CSS scoped to a specific 
        component

        it avoids global namespace conflicts by generating unique
        class names at build time 

            working : 
                create a CSS file with the .module.css extension 
                import it into your component 
                apply styels using the imported object 

            File structure : 
                src/ 
                    components/
                        Button/
                            Button.module.css 
                            Button.js 
            
            Button.module.css 

                .button {
                    background-color : blue;
                    color : white;
                    padding:10px 20px;
                    border : none;
                    border-radius : 5px;
                    cursor:pointer;
                }
            
            Button.js 

                import React from "react"
                import styles from "./Button.module.css"

                function Button(){
                    return <button className={style.button}> Click Me </button>
                }

                export default Button; 

            class names are locally scoped(eg. button will not 
            conflict with other .button classes);

    Styled-components or Emotion.

        import React from "react";
        import styled from "styled-components";

        const Button = styled.button`
        background-color: blue;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;

        &:hover {
            background-color: darkblue;
        }
        `;

        function App() {
        return <Button>Click Me</Button>;
        }

        export default App;

        key points : 

            styles are scoped to components 
            supports dynamic styling with props 

            const Button = styled.button`
                background-color: ${(props) => (props.primary ? "blue" : "gray")};
            `;
        
        adv. of emotions : 
            emotion offers similar functionality with 
            additional flexibility, such as using the 
            css props for inline styles and sercer-side 
            rendering (SSR) support.
        

    Inline styles and utility-first CSS (e.g., Tailwind CSS).
        
        involve applying styles directly to an element using the style 
        attribute the style are written as a JS object

        working : 

            styles are specified as an object, with 
            proprty names in camelCase.

        code : 

            import React from "react";

            function App(){
                const buttonStyle = {
                    backgroundColor : "blue",
                    color : "white",
                    padding : "10px 20px",
                }

                return <button style={buttonStyle}> Click me </button> 

            }

            export default App;

            lacks psudo classes like : hover 

        
        utility-first CSS : 

            tailwind CSS is a 

    Css modules : 

        scoped per file 
        avoids class name conflicts, reusable styles 
        slightly verbose for small components 

    styled-comp : 
        scoped per component 
        dynamic styling with props
        better for mordern apps 
        requires addditional dependency 

    inline styles : 
        scoped per element 
        good for dynamic styles 
        simple 
        cannot handle pesudo-class 
    
    tailwind CSS : 
        global utility 
        rapid develpment styles 
        consistent design system 
        steep learning curve 

Error Handling:
    Error boundaries (componentDidCatch in class components).   
        catch JS errors anywhere in their child component tree 
        log error 
        display fallback UI instead of crashing entire app 

        key points : 

            only works for rendering, lifecycle methods and 
            constructors of child comps 

            does not carch error in : 
                event handlers
                async code 
                server-side rendering 
                Errors thrown in the error boundary itself 
        
        create error boundary :

            using componentDidCatch lifecycle method 
            in a class comp 

            import React, {Component} from "react" ;

            class ErrorBoundary extends Component{
                constructor(props){
                    super(props);
                
                    this.state = {hasError:false, error:null};
                    console.log("ErrorBounndary Constructor : initialized);

                }

                static getDerivedStateFromError(error){
                    //update state to show fallback UI
                    console.log("ErrorBoundary getDerivedStateError : Error Detected");
                    return {hasError:true, error};
                }

                componentDidCatch(error, errorInfo){
                    //log error details 
                    console.error("Error Caught :", error, errorInfo);
                }

                render(){
                    if(this.state.hasError)
                    {
                        return <h1> Something went wrong. Pleasr try again later.</h1>
                    }

                    return this.props.children;
                }
            }

    Handling errors gracefully with React.

        common errors in react : 

            rendering comps(incorrect props or state usage)
            event handling (failed API calls or invalid input)
            Lifecycle methods (eg. accessing unavailable data in componentDidMount)

        techniques to handle errors :   
            1. error boundaries
            2. try-catch in event-handlers
            3. try-catch in async code
            4. fallback UI for uncaught errors 
            5. logging errors 
            6. handling errors at API level 


Refs and DOM Manipulation:
    Using React.forwardRef.
        higher order func that allows a parent comp to 
        pass a ref to child comp. 

        refs cannot be passed to functional comp directly 
        as they are not DOM elements. 
        React.forwardRef enebles functional comps to handle refs 

            React.forwardRef takes a funtional Comp 
            and allows it to accept ref as its second param 

            the ref can then be attached to a DOM element or 
            passed further down the tree 

    code : 

        import React, {useRef} from 'react' 

        //child comp using forwardRef 
        const CustomInput = React.forwardRef((props, ref) => {
            return <input ref={ref} {...props} />
        })

        function App(){
            const inputRef = useRef(null);

            const focusinput = () => {
                inputRef.current.focus();
            }

            return (
                <div>   
                    <CustomInput ref={inputRef} />
                    button onClick={focusInput} focus input /button 
                </div>
            )
        }


        useRef is a react hook that provides a way to 
        hold a reference to a DOM element or a mutable 
        value that persists acriss the renders 

        it does not trigger re-render when its value changes 

    customizing ref behavior
        
        combine React.forwardRedf with the useImperativeHandle hook
        this allows you to expose specific methods or properties 
        of a child comp to its parent 
    
    code : 

        import React, {useRef, forwardRef, useImperativeHandle} from "rect" 

        //child comp 
        const CustomInput = forwardRef((props,ref) => {
            const inputRef = useRef();

            //exposing custom methods 
            useImperativeHandle(ref, () => ({
                focusInput: () => inputRef.current.focus(),
                clearInput: () => (inputRef.current.value = ""),
            }));

            return <input ref={inputRef} {...props} />
        })

        function App(){
            const inputRef = useRef();

            return (
                div
                    <CustomInput ref={inputRef} />
                    button onClick={() => inputRef.current.focusInput()}
                        Focus Input 
                    /button 

                    button onClick={()=> inputRef.current.clearInput()}
                        clear input 
                    /button                     

                /div
            )
        }


    Manipulating DOM with useRef.

Advanced Hooks:
    Custom Hooks (extracting reusable logic).
        when multiple comps in your app need to share common 
        logic, writting the same code in each comp result 
        in duplication 
        instead you can extract this logic into a custom Hook 
        for reusability 

        preficsed with use 
        like useState 

        code : 

            import {useStatem useEffect} from "react" 

            export fuction useFetch(url){
                const [data, setData] = useState(null);
                const [loading, setLoading] = useState(true);
                const [error, setError] = useState(null);

                useEffect(()=>{
                    const fetchData = async () => {
                        try{
                            const respose = await fetch(url);

                            if(!response.ok)
                            {
                                throw new Error("Network response was not ok")
                            }

                            const json = await response.json()
                            setData(json);

                        } catch (err) {
                            setError(err.message);
                        } finally {
                            setLoading(false);
                        }
                    };

                    fetchData();

                },[url]);

                return {data, loading, error};
            }


        usage : 

            import React from "react" 
            import {useFetch} from "./useFetch";

            function App(){
                const {data, loading, error} = useFetch("httpl....")

                if(loading)
                    return p loading /p 
                
                if(error) 
                    return p error : {error} /p 
                

                return (
                    div 
                        ul 
                            {data.map((post) => (
                                li key={post.id} {post.title} /li
                            ))}
                        /ul 
                    /div
                )
            }

            export default App;


    useLayoutEffect vs. useEffect.

        both hooks allow u to run side effects in func comps 

        useEffect : 
            runs after the browser has painted the UI 
            non-visual side effects like fetching data or 
            logging 
            does not block UI rendering 

        useLayoutEffect :   
            runs synchronously after DOM mutations but 
            before the browser paints 
            visual side effects like measuring DOM 
            size/positions, animations or updating layout styles 
            
        code : 

            import React, { useLayoutEffect, useRef, useState } from "react";

            function Box() {
            const boxRef = useRef();
            const [boxWidth, setBoxWidth] = useState(0);

            useLayoutEffect(() => {
                // Measure the width of the box before the browser paints
                setBoxWidth(boxRef.current.offsetWidth);
            }, []);

            return (
                <div>
                <div ref={boxRef} style={{ width: "200px", height: "100px", background: "lightblue" }}>
                    Box
                </div>
                <p>Box width: {boxWidth}px</p>
                </div>
            );
            }

            export default Box;



React Performance Optimization:
    React.memo and PureComponent.
        when a comp re-renders unnecessarily due to 
        changes in its parent comp or the app's state 
        performance may degrade 
        React.memo and PureComp help prevent such redundant 
        re0renders 

        React.memo : 
            is a HOC that memoizes a fuctional comp 

            it prevents re-renders if the props of the 
            components have not changed 
    
    PureComp 

        class comp that performs a shallow comparison 
        of props an state to determine if a re-renfer
        is necessary 

        it avoids unnecessary re-renders if neither props 
        nor state has changed 

        same as React.memo but it is used in class comp.



    Lazy loading with React.lazy and Suspense.

        when app has many router or large comps 
        loading them all upfront can slow down the app 
        lazy loading dynamically loads only what is needed 
        reducing the initial load time 

        React.lazy allows u dynamically import components 
        it works in conjunction with suspense to show a fallback 
        while the comp is being loaded 

        code : 

            import React, {Suspense} from "react" 

            const LazyComponent = React.lazy(()=> import("./LazyComponent))

            function App(){
                return (
                    <div>
                        <Suspense fallback={<p Loading..</p> }>
                            <LazyComponent />
                        </Suspense>
                    </div>
                )
            }

        
        Lazy loading is particularly effective with route-based 
        splitting 

        code : 
            
            import React, {Suspense} from "react"
            import {BrowserRouter as Router, Routes, Route} from "react-router-dom";

            const Home = React.lazy(() => import("./Home"))
            const About = React.lazy(() => import("./About"));

            function App(){
                return(
                    <Router>
                        <Suspense fallback={<p>Loading..</p>}>
                            Routes 
                                Route path="/" element={<Home/>} 
                                Route path="/about" element={<About/>} />
                            /Routes 
                        /Suspense 
                    /Router 
                )
            }

            export dafault App;

    Code splitting : 

        splitting code in multiple chunks and call dynamically when 
        needed 


React Query (TanStack Query):

    code : 

        import React from "react";
        import { useQuery } from "@tanstack/react-query";


        function Example() {
            
            const { isPending, error, data, isFetching } = useQuery({
                queryKey: ["repoData"],
                queryFn : async () => {
                    const response = await fetch(
                        'https://api.github.com/repos/TanStack/query'
                    )
                    
                    return await response.json();
                }
            })


            if(isPending) return 'Loading...';
            if(error) return 'An error occurred: ' + error.message;

            return (
                <div className="m-4 p-4 border-2 border-gray-300 rounded-md">
                    <ul className="list-none">
                        <li>
                            <h1 className="text-3xl font-bold underline">{data.full_name} </h1>
                            <p className="text-xl">{data.description} </p>
                            <strong className="text-lg">{data.subscribers_count} </strong>
                            <div className="text-sm">{isFetching ? 'Updating...' : ''} </div>
                        </li>
                    </ul>
                    
                </div>
            )

        }

        export default Example;

    lib for managing server state in React applications 
    it simplifies data fetching, caching, synchroniz
    Data fetching, caching, and synchronization and state 
    management of server-side data, reducing boilerplate code 
    and improving performance 

    useQuery hook : 
        returns an object containing various properties that 
        help manage the state of a query, such as loading, 
        error and data 
        
        parameters : 
            queryKey : 
                uniquely identifies this query (["repoData"])
                React Query uses this key to cache and manage 
                the query data.
            
            queryFn : 
                the function that performs the data fetch

        
        what it returns : 
            key properties :    
                data 
                    the result of the query(queryFn)
                    this will contain the fetched data once query is successful
                    default value is undefined until the query is resolved 

        advantages over vanilla fetch and state management : 

        state management : 

            React query automatically manages loading, error 
            and success states (isPending, isFetching, error,
            data) so you dont need to write extra state management 
            logic (useState, useEffect)

        caching : 

            rect query caches the data and avoids redundant API 
            calls if the query key remains the same it only fetches 
            data again if explicitely invalidated or if the cache 
            expires 
                
        background fetching : 

            the isFetching property allows displaying 
            background loading indicators when the query is 
            refetched 
        
        declarative syntax : 

            useQuery API is declarative, making it easier to 
            read and maintain compard to traditional fetch 
            calls and state handlinf 
        
        used for : 
            pagination 
            infinite scrolling 
            dependent queries 
            server state synchronization
            

    Managing server state efficiently.



fetch vs axios

    fetch : not http error handling only network error handling
    axios : provides both 

    fetch : no built int timeout support
    axios : timeout method built-in 

    fetch : must manually json parsing 
    axios : built in json parsing 

    fetch : no middleware like function 
    axios : built in interceptor that acts like middleware 